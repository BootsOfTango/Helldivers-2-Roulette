<!doctype html>
<!--
===============================================================================
AI MASTER DIRECTIVE
HELldivers 2 CHAOS ROULETTE — PERFORMANCE STAT LAB
READ THIS FIRST BEFORE TOUCHING ANY CODE
===============================================================================


===============================================================================
CORE IDENTITY OF THIS PROGRAM
===============================================================================

THIS IS NOT A RANDOM LOADOUT GENERATOR.

This application is a STRUCTURED GAMEPLAY EXPERIMENTATION LAB.

Operational Loop:

SPIN → PLAY → RECORD → EVALUATE → RANK → COMPARE → LEARN

Purpose:
Convert subjective gameplay experience into objective historical data.

This system functions as a PERSONAL PERFORMANCE ANALYTICS ENGINE
("Moneyball for Helldivers").

Chaos generates experiments.
Experiments generate data.
Data reveals mastery.


===============================================================================
INTENDED USER WORKFLOW (OPTIMAL USE CASE)
===============================================================================

1. ITEM OWNERSHIP SETUP
User edits weapon/stratagem lists once to match real in-game ownership.
This rarely changes afterward.

Only ENABLED items participate in roulette.


2. LIVE PLANET SOURCE
Only ACTIVE HELLDIVER-READY planets must be available
from external API endpoint BEFORE planet roll.

Planet availability must reflect live game state.


3. LOADOUT SPIN
User spins loadout.

System generates:
- randomized equipment
- conceptual SEED NAME matching loadout identity


4. PLANET ROLL
User rolls planet AFTER loadout generation.

Rules:
- Planet chosen from ACTIVE API list
- Detailed biome/hazard/environment pulled locally
  from HTML planet database
- Planet may reroll
- FACTION becomes LOCKED after first roll
  (prevents infinite favorable reroll abuse)


5. CONFIRMATION
Once confirmed:

A LOADOUT CARD is created in RESULTS tab.

Card state BEFORE gameplay:
- visually blurred/shaded
- clear center text: "EDIT!"
- excluded from ranking system
- radar not finalized


6. MISSION EXECUTION
User plays real Helldivers mission.


7. MANUAL STAT ENTRY
After mission completion user enters stats.


8. CARD ACTIVATION
After saving stats:
- card becomes ACTIVE dataset
- radar pentagon generated
- rank system includes card
- tier color applied


===============================================================================
MISSION RESULT STATS (PLAYER INPUT)
===============================================================================

Kills
→ Offensive Power

Accuracy (%)
→ Mechanical Skill

Deaths + Stims Used
→ Survivability / Endurance (combined internally)

Distance Traveled (km)
→ Mobility / Positioning

Stratagem Uses
→ Tactical Utility


Radar Pentagon represents PLAYER ARCHETYPE FINGERPRINT.


===============================================================================
MAJOR ORDER (MO) PERFORMANCE RULE
===============================================================================

Each result card asks:
MAJOR ORDER SUCCESS? (YES / FAIL)

If SUCCESS:
- stats used normally

If FAIL:
- ALL ranking values reduced by 25%
- radar pentagon scaled to 75%
- ranking score reduced equally

IMPORTANT:
Displayed statistics remain TRUE values.

Example:
100 kills + MO FAIL → ranking value = 75
75 kills + MO SUCCESS → equal ranking impact

Visual honesty preserved.
Performance consequence enforced.


===============================================================================
TIER COLOR PROPAGATION (ABSOLUTE RULE)
===============================================================================

Once ranked:

Tier color MUST apply consistently to:
- Card rim
- Radar pentagon stroke/fill
- Seed name text
- Rank display
- Compare visualization

Color inheritance always originates from CARD RANK.


===============================================================================
RANK + COMPARE SYSTEM (MERGED DESIGN)
===============================================================================

COMPARE TAB NO LONGER EXISTS.

Rank tab becomes unified ANALYSIS SPACE.


LEFT SIDE UI:
- Compact ranked card list
- Smaller card boxes
- Scrollable performance archive


RIGHT SIDE UI:
Dynamic comparison workspace.


Behavior:

Click ranked card →
→ fills comparison slot.

Two comparison slots displayed horizontally.

Each slot shows:
- Enlarged radar pentagon
- LARGE readable stat labels at each vertex
(no tiny text)


Click selected card again →
→ removes from comparison slot.


Above comparison:
Display stats WON by LEFT card.

Below comparison:
Display stats WON by RIGHT card.

Goal:
Visual causal comparison,
not numeric competition.


===============================================================================
PLANET IMMERSION SYSTEM
===============================================================================

Planet roll displays:

- biome
- hazards
- faction
- sector
- environmental conditions

Each attribute should include fitting EMOJIS
representing environmental identity.

Environment acts as gameplay stress variable
within performance analysis.


===============================================================================
CARD PHILOSOPHY
===============================================================================

One mission = One card.
One card = One dataset.
Cards are historical experiments.

Cards function simultaneously as:
- UI element
- database record
- ranking participant
- analytical object


===============================================================================
AI RESPONSIBILITY (CRITICAL)
===============================================================================

USER DOES NOT CODE.

AI performs ALL implementation work.

User only:
uploads files → tests → reports behavior.


MANDATORY AI WORKFLOW:

1. Read ENTIRE HTML.
2. Understand system flow BEFORE debugging.
3. Identify root cause logically.
4. Create internal fix plan.
5. Apply MINIMUM safe change.
6. Preserve architecture.
7. Deliver updated HTML + TXT log.


===============================================================================
SYSTEM SAFETY RULES
===============================================================================

- Card object is single source of truth.
- Never duplicate element IDs.
- Events bind once only.
- Rank determines visuals globally.
- Compare reads ranked cards only.
- Never redesign unrelated systems.


===============================================================================
AI SUCCESSION PROTOCOL
===============================================================================

Future AI MUST read:

1) This HTML directive
2) Attached TXT LOG FILE

TXT log contains reasoning history.

Never restart investigation from zero.


===============================================================================
END MASTER DIRECTIVE
===============================================================================
-->
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Helldivers 2 Chaos Roulette</title>
    <style>


        :root {
            --bg: #0b0d10;
            --panel: #10141a;
            --panel2: #0e1217;
            --line: rgba(255,255,255,.10);
            --line2: rgba(255,255,255,.06);
            --text: #e8eef7;
            --muted: #a6b0bf;
            --yellow: #ffd400;
            --red: #ff3b3b;
            --white: #ffffff;
            --good: #2ecc71;
            --bad: #ff5a5a;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
            --shadow: 0 12px 40px rgba(0,0,0,.45);
            --radius: 16px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: var(--sans);
            color: var(--text);
            background: #07080a;
            position: relative;
            z-index: 1;
        }

        header {
            padding: 18px 18px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            border-bottom: 1px solid var(--line2);
            position: sticky;
            top: 0;
            background: rgba(11,13,16,.85);
            backdrop-filter: blur(10px);
            z-index: 10;
        }

            header .title {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            header h1 {
                margin: 0;
                font-size: 16px;
                letter-spacing: .2px;
            }

            header .sub {
                font-size: 12px;
                color: var(--muted);
            }

            header .pillRow {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                justify-content: flex-end;
            }

        .pill {
            border: 1px solid var(--line);
            background: rgba(255,255,255,.03);
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
        }

            .pill strong {
                color: var(--text);
                font-weight: 600;
            }

            .pill.yellow {
                border-color: rgba(255,212,0,.30);
                color: rgba(255,212,0,.95);
                background: rgba(255,212,0,.06);
            }

            .pill.red {
                border-color: rgba(255,60,60,.30);
                color: rgba(255,60,60,.95);
                background: rgba(255,60,60,.07);
            }

        main {
            padding: 14px 18px 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            padding: 10px 0 14px;
        }

        .tabBtn {
            cursor: pointer;
            user-select: none;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.03);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 999px;
            font-weight: 600;
            font-size: 12px;
            transition: .15s ease;
        }

            .tabBtn:hover {
                transform: translateY(-1px);
                border-color: rgba(255,255,255,.18);
            }

            .tabBtn.active {
                border-color: rgba(255,212,0,.45);
                background: rgba(255,212,0,.08);
                color: rgba(255,212,0,.95);
            }

        /* Panels */
        .panel {
            background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
            border: 1px solid var(--line);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 14px;
        }

            .panel + .panel {
                margin-top: 12px;
            }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: stretch;
        }

        .col {
            flex: 1;
            min-width: 260px;
        }

        .btnRow {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 12px;
        }

        button {
            cursor: pointer;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.03);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: .2px;
            transition: .15s ease;
        }

            button:hover {
                transform: translateY(-1px);
                border-color: rgba(255,255,255,.20);
            }

            button:disabled {
                opacity: .45;
                cursor: not-allowed;
                transform: none;
            }

        .btnPrimary {
            border-color: rgba(255,212,0,.45);
            background: rgba(255,212,0,.10);
            color: rgba(255,212,0,.95);
        }

        .btnDanger {
            border-color: rgba(255,60,60,.35);
            background: rgba(255,60,60,.08);
            color: rgba(255,120,120,.95);
        }

        .btnGhost {
            background: rgba(255,255,255,.02);
        }

        .label {
            color: var(--muted);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: .6px;
            margin-bottom: 6px;
        }

        .big {
            font-size: 20px;
            font-weight: 900;
            letter-spacing: .2px;
        }

        .box {
            background: rgba(0,0,0,.18);
            border: 1px solid var(--line2);
            border-radius: 14px;
            padding: 12px;
            min-height: 78px;
        }

        .tiny {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.35;
        }

        .divider {
            height: 1px;
            background: var(--line2);
            margin: 12px 0;
        }

        /* Hide loadout results until reels finish */
        #loadoutRevealBlock {
            transition: opacity .25s ease;
        }

        .spinHidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Slot reels */
        /* ===== SLOT COLOR THEMES ===== */
        .slot {
            font-family: var(--mono);
            font-size: 14px;
            border-radius: 12px;
            padding: 10px 12px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* Weapon reels */
        .slot-primary {
            border: 2px solid #2ecc71;
            background: rgba(46,204,113,.08);
            color: #2ecc71;
        }

        .slot-sidearm {
            border: 2px solid #ffd400;
            background: rgba(255,212,0,.08);
            color: #ffd400;
        }

        .slot-throwable {
            border: 2px solid #ff8c00;
            background: rgba(255,140,0,.08);
            color: #ff8c00;
        }

        .slot-strat {
            border: 2px solid #ff4f7a;
            background: rgba(255,79,122,.08);
            color: #ff3b3b;
        }

        .slotGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 14px 18px;
            max-width: 980px;
            margin: 0 auto;
            margin-top: 8px;
        }

        .slotCol {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slotRow {
            display: grid;
            grid-template-columns: 86px minmax(220px, 420px);
            gap: 10px;
            align-items: center;
        }

        .slotTag {
            font-family: var(--mono);
            font-size: 12px;
            color: var(--muted);
            border: 1px solid var(--line);
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255,255,255,.03);
            text-align: center;
            white-space: nowrap;
        }


        /* Cards */
        .cardGrid {
            display: grid;
            grid-template-columns: repeat(3, minmax(260px, 1fr));
            gap: 12px;
        }

        #resultsGrid.cardGrid {
            grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
        }

        @media (max-width: 980px) {
            .cardGrid {
                grid-template-columns: repeat(2, minmax(260px, 1fr));
            }

            #resultsGrid.cardGrid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 620px) {
            .cardGrid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: rgba(0,0,0,.22);
            border: 2px solid rgba(255,255,255,.10);
            border-radius: 16px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }

        /* Pentagon / radar mini chart (Results cards) */
        .radarWrap {
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,.12);
            border: 1px solid var(--line2);
            border-radius: 14px;
            padding: 8px;
            margin-top: 10px;
        }

        .radarGrid polygon,
        .radarGrid line {
            stroke: rgba(255,255,255,.22);
            stroke-width: 1;
            fill: none;
        }

        /* ===== RADAR COLOR INHERIT FROM CARD TIER ===== */
        .card {
            --radarStroke: rgba(255,255,255,.75);
            --radarFill: rgba(255,255,255,.35);
            --radarDot: var(--radarStroke);
        }

            .card.tier-gold {
                --radarStroke: #ffd400;
                --radarFill: rgba(255,212,0,.38);
                --radarDot: #ffd400;
            }

            .card.tier-silver {
                --radarStroke: #c8d2dc;
                --radarFill: rgba(200,210,220,.38);
                --radarDot: #c8d2dc;
            }

            .card.tier-bronze {
                --radarStroke: #e6aa5a;
                --radarFill: rgba(230,170,90,.38);
                --radarDot: #e6aa5a;
            }

            .card.tier-darkbronze {
                --radarStroke: #965f28;
                --radarFill: rgba(150,95,40,.38);
                --radarDot: #965f28;
            }

            .card.tier-rainbow {
                --radarStroke: url(#rainbowStroke);
                --radarFill: rgba(255,255,255,.15);
                --radarDot: #ffffff;
            }

        .radarFill {
            stroke: var(--radarStroke) !important;
            fill: var(--radarFill) !important;
            stroke-width: 2 !important;
            filter: drop-shadow(0 0 6px var(--radarStroke));
        }

        .radarDot {
            fill: var(--radarDot) !important;
        }

        /* ===== RAINBOW TIER FORCE SVG STROKE (FIX) ===== */


        /* ===== UNIVERSAL TIER RADAR SYSTEM (FINAL) ===== */
        .card[class*="tier-"] .radarFill,
        .card[class*="tier-"] .radarValue {
            stroke: var(--radarStroke) !important;
            fill: var(--radarFill) !important;
            filter: drop-shadow(0 0 6px var(--radarStroke));
        }

        /* Rainbow exception (gradients cannot shadow) */
        .card.tier-rainbow .radarFill,
        .card.tier-rainbow .radarValue {
            stroke: url(#rainbowStroke) !important;
            fill: rgba(255,255,255,.15) !important;
            filter: none !important;
        }

        /* ===== SILVER TIER RADAR FORCE FIX ===== */
        .card.tier-silver .radarFill,
        .card.tier-silver .radarValue {
            stroke: #c8d2dc !important;
            fill: rgba(200,210,220,.38) !important;
            filter: drop-shadow(0 0 6px #c8d2dc) !important;
        }

        .card.tier-rainbow .radarFill,
        .card.tier-rainbow .radarValue {
            stroke: url(#rainbowStroke) !important;
            fill: rgba(255,255,255,.15) !important;
            filter: none !important; /* drop-shadow breaks gradient strokes */
        }

        .cardTop {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: flex-start;
        }

        .cardTitle {
            font-weight: 900;
            font-size: 14px;
            letter-spacing: .2px;
        }

        .cardMeta {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.35;
        }

        .cardLine {
            font-size: 12px;
            color: var(--text);
            line-height: 1.35;
        }

            .cardLine strong {
                color: rgba(255,212,0,.95);
            }

        .badge {
            font-size: 11px;
            border: 1px solid var(--line);
            border-radius: 999px;
            padding: 5px 8px;
            color: var(--muted);
            white-space: nowrap;
        }

            .badge.yellow {
                border-color: rgba(255,212,0,.35);
                background: rgba(255,212,0,.08);
                color: rgba(255,212,0,.95);
            }

            .badge.red {
                border-color: rgba(255,60,60,.35);
                background: rgba(255,60,60,.08);
                color: rgba(255,120,120,.95);
            }

            .badge.good {
                border-color: rgba(46,204,113,.35);
                background: rgba(46,204,113,.08);
                color: rgba(46,204,113,.95);
            }

        input, select, textarea {
            width: 100%;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.03);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 10px;
            font-size: 12px;
            outline: none;
        }

        /* ===== DROPDOWN READABILITY FIX ===== */

        /* Closed select box */
        select {
            color: #eaeaea;
            background: #111;
            border: 1px solid #444;
        }

            /* Open dropdown options */
            select option {
                color: #000;
                background: #fff;
            }

            select optgroup {
                color: #000;
                background: #fff;
            }

        textarea {
            min-height: 88px;
            resize: vertical;
        }

        .formGrid {
            display: grid;
            grid-template-columns: repeat(2, minmax(160px, 1fr));
            gap: 10px;
        }

        .formGrid3 {
            display: grid;
            grid-template-columns: repeat(3, minmax(140px, 1fr));
            gap: 10px;
        }

        .statsGrid {
            align-items: start;
        }

            .statsGrid > div {
                display: flex;
                flex-direction: column;
            }

            .statsGrid > div .label {
                min-height: 30px;
                line-height: 1.2;
                display: flex;
                align-items: flex-end;
            }

        .cardInputGrid {
            grid-template-columns: repeat(3, minmax(140px, 1fr));
        }

        .cardInputGrid .label {
            min-height: 32px;
            white-space: nowrap;
        }

        .cardMetaGrid {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(2, minmax(220px, 1fr));
            gap: 10px;
            align-items: start;
        }

        .formGrid4 {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 10px;
        }

        /* Force 2 columns on narrower screens so inputs stay inside the card */
        @media (max-width: 720px) {
            .formGrid4 {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        @media (max-width: 820px) {
            .formGrid3, .formGrid4 {
                grid-template-columns: repeat(2, minmax(140px, 1fr));
            }

            .cardInputGrid {
                grid-template-columns: repeat(2, minmax(140px, 1fr));
            }

            .cardMetaGrid {
                grid-template-columns: 1fr;
            }
        }

        .miniRow {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .hr {
            height: 1px;
            background: var(--line2);
            margin: 10px 0;
        }


        /* ===== COMPARE RADAR ===== */
        .radarCompareWrap {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .cmpRadarRow {
            display: grid;
            grid-template-columns: repeat(2, minmax(260px, 1fr));
            gap: 12px;
        }

        .cmpRadar,
        .cmpRadarOverlay {
            min-height: 290px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,.2);
            border: 1px solid var(--line2);
            border-radius: 14px;
            padding: 10px;
        }

        .cmpRadarOverlay svg title {
            pointer-events: none;
        }

        @media (max-width: 960px) {
            .cmpRadarRow {
                grid-template-columns: 1fr;
            }
        }
        /* Overlay radar colors are set dynamically per compared card (tier colors) */
        .overlayA .radarValue {
            fill: var(--ovFill, rgba(46,204,113,.25)) !important;
            stroke: var(--ovStroke, #2ecc71) !important;
        }

        .overlayB .radarValue {
            fill: var(--ovFill, rgba(255,60,60,.25)) !important;
            stroke: var(--ovStroke, #ff3b3b) !important;
        }
        /* Compare highlight */
        .cmpTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

            .cmpTable th, .cmpTable td {
                border-bottom: 1px solid var(--line2);
                padding: 8px 6px;
                text-align: left;
                vertical-align: top;
            }

        .good {
            color: var(--good);
            font-weight: 800;
        }

        .bad {
            color: var(--bad);
            font-weight: 800;
        }

        .muted {
            color: var(--muted);
        }

        /* Rank */
        .rankRow {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            align-items: center;
            padding: 10px;
            border: 1px solid var(--line2);
            border-radius: 14px;
            background: rgba(0,0,0,.18);
        }

        .rim-white {
            border-color: rgba(255,255,255,.70) !important;
        }

        .rim-gold {
            border-color: rgba(255,212,0,.75) !important;
        }

        .rim-silver {
            border-color: rgba(200,210,220,.80) !important;
        }

        .rim-bronze {
            border-color: rgba(205,127,50,.80) !important;
        }

        .rankOuter {
            border-radius: 14px;
            background: transparent;
        }
        /* ===== RESULT CARD TIER COLORS ===== */

        .card.tier-gold {
            border-color: rgba(255,212,0,.75);
        }

        .card.tier-silver {
            border-color: rgba(200,210,220,.85);
        }

        .card.tier-bronze {
            border-color: rgba(230,170,90,.85);
        }

        .card.tier-darkbronze {
            border-color: rgba(150,95,40,.85);
        }

        .card.tier-rainbow {
            position: relative;
        }

            .card.tier-rainbow::before {
                content: "";
                position: absolute;
                inset: -2px;
                border-radius: 18px;
                padding: 2px;
                background: conic-gradient( #ff3b3b, #ffd400, #2ecc71, #3b82f6, #a855f7, #ff3b3b );
                -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
                -webkit-mask-composite: xor;
                mask-composite: exclude;
                pointer-events: none;
            }

        .rankOuter > .rankRow {
            background: rgba(0,0,0,.92);
        }

        .rim-rainbow {
            padding: 4px;
            border-radius: 14px;
            background: conic-gradient( #ff3b3b, #ffd400, #2ecc71, #3b82f6, #a855f7, #ff3b3b );
        }

            .rim-rainbow > .rankRow {
                border-radius: 11px;
            }

        canvas {
            width: 100%;
            height: 320px;
            background: rgba(0,0,0,.18);
            border: 1px solid var(--line2);
            border-radius: 14px;
        }

        /* ===== GRAPH TOOLTIP ===== */
        .graphTip {
            position: fixed;
            z-index: 9999;
            display: none;
            max-width: 360px;
            padding: 10px 10px;
            border-radius: 12px;
            background: rgba(0,0,0,.92);
            border: 1px solid rgba(255,255,255,.14);
            box-shadow: 0 14px 40px rgba(0,0,0,.6);
            color: #e8eef7;
            font-size: 12px;
            line-height: 1.35;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }

            .graphTip .tTitle {
                font-weight: 900;
                margin-bottom: 6px;
                font-size: 12px;
            }

            .graphTip .tLine {
                color: rgba(255,255,255,.85);
                margin: 2px 0;
            }

            .graphTip .tMuted {
                color: rgba(255,255,255,.55);
            }

            .graphTip .tBadge {
                display: inline-block;
                margin-left: 6px;
                padding: 2px 6px;
                border-radius: 999px;
                border: 1px solid rgba(255,255,255,.14);
                color: rgba(255,212,0,.95);
                background: rgba(255,212,0,.08);
                font-size: 11px;
                font-weight: 800;
            }

        .smallHelp {
            font-size: 11px;
            color: var(--muted);
            line-height: 1.35;
            margin-top: 6px;
        }

        .right {
            text-align: right;
        }

        /* Make Rank list scroll if it gets tall */
        #rankList {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 520px;
            overflow: auto;
            padding: 10px 6px 10px 0;
            scroll-padding-top: 10px;
            box-sizing: border-box;
        }

        /* ===== YOUTUBE PROMO ANIMATION ===== */

        .ytPromo {
            font-size: 13px;
            color: #ff3b3b;
            font-weight: 600;
            display: flex;
            align-items: center;
            white-space: nowrap;
            /* make room for the arrow to sit on the left side */
            position: relative;
            padding-left: 22px;
        }

        .arrow {
            /* anchor arrow at the left edge of the promo text */
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%) rotate(180deg);
            display: inline-block;
            animation: arrowMove 1s infinite alternate;
        }

        /* wiggle toward the pig (left), not away from it */
        @keyframes arrowMove {
            from {
                transform: translateY(-50%) rotate(180deg) translateX(0);
            }

            to {
                transform: translateY(-50%) rotate(180deg) translateX(-6px);
            }
        }


        /* ===== BACKGROUND FIX: LOGO ONLY ON EDGES ===== */

        html {
            background: #07080a;
        }

        body {
            background: transparent;
            z-index: 0;
            isolation: isolate;
        }

            body::before {
                content: "";
                position: fixed;
                /* slightly less oversized so letters aren't chopped */
                inset: -10vh -10vw;
                /* smaller than before (was 140vmax) */
                background: url("Helldivers-2-Logo.png.png") center / 90vmax no-repeat;
                opacity: 0.14;
                pointer-events: none;
                z-index: -1;
                -webkit-mask-image: radial-gradient(circle at center, transparent 0 42%, rgba(0,0,0,1) 60%, rgba(0,0,0,1) 100% );
                mask-image: radial-gradient(circle at center, transparent 0 42%, rgba(0,0,0,1) 60%, rgba(0,0,0,1) 100% );
            }
        /* ===== MODE COLORS ===== */

        .mode-standard {
            color: #ffd400;
            font-weight: 900;
        }

        .mode-blitz {
            color: #ff8c00;
            font-weight: 900;
        }

        /* ===== FACTION COLORS ===== */

        /* ===== FACTION COLORS (TEXT ONLY) ===== */
        .faction-terminids {
            color: #ffd400;
        }

        .faction-automatons {
            color: #ff3b3b;
        }

        .faction-illuminate {
            color: #a855f7;
        }



        .faction-superearth {
            color: #e8eef7;
        }
        /* ===== HEADER FACTION PILL FIX ===== */
        .pill.faction-terminids,
        .pill.faction-automatons,
        .pill.faction-illuminate,
        .pill.faction-superearth {
            color: var(--muted);
            font-weight: normal;
        }

        .pill.faction-terminids {
            border-color: rgba(255,212,0,.30);
            background: rgba(255,212,0,.06);
        }

        .pill.faction-automatons {
            border-color: rgba(255,60,60,.30);
            background: rgba(255,60,60,.07);
        }

        .pill.faction-illuminate {
            border-color: rgba(168,85,247,.30);
            background: rgba(168,85,247,.07);
        }

        .pill.faction-terminids strong {
            color: #ffd400;
        }

        .pill.faction-automatons strong {
            color: #ff3b3b;
        }

        .pill.faction-illuminate strong {
            color: #a855f7;
        }
        /* ===== RANK TIER RIMS (matching your tier plan) ===== */
        .rim-darkbronze {
            border-color: rgba(150,95,40,.85) !important;
        }

        .rim-brown {
            border-color: rgba(120,80,45,.85) !important;
        }

        /* Optional: make bronze tiers visually different (light vs dark) */
        .rim-bronze {
            border-color: rgba(230,170,90,.85) !important;
        }

        .planetCardWrap {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .planetMiniCard {
            background: rgba(0,0,0,.25);
            border: 1px solid var(--line2);
            border-radius: 12px;
            padding: 8px 10px;
            min-width: 120px;
        }

        .planetMiniLabel {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: .6px;
            color: var(--muted);
            margin-bottom: 4px;
        }

        .planetMiniValue {
            font-size: 12px;
            font-weight: 800;
        }

        .planetTagRow {
            margin-top: 6px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .planetTag {
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.05);
        }

        .cmpTitle {
            text-align: center;
            font-weight: 900;
            margin-bottom: 6px;
            color: #e8eef7;
            letter-spacing: .4px;
        }

        /* ===== COMPARE SEED TITLE COLOR MATCH ===== */
        .overlayA .cmpTitle {
            color: var(--ovStroke, #2ecc71);
        }

        .overlayB .cmpTitle {
            color: var(--ovStroke, #ff3b3b);
        }
    </style>

</head>
<body>

    <!-- GLOBAL RAINBOW RADAR GRADIENT -->
    <svg width="0" height="0" style="position:absolute">
        <defs>
            <linearGradient id="rainbowStroke" gradientUnits="userSpaceOnUse"
                            x1="0" y1="0" x2="200" y2="200">
                <stop offset="0%" stop-color="#ff3b3b" />
                <stop offset="20%" stop-color="#ffd400" />
                <stop offset="40%" stop-color="#2ecc71" />
                <stop offset="60%" stop-color="#3b82f6" />
                <stop offset="80%" stop-color="#a855f7" />
                <stop offset="100%" stop-color="#ff3b3b" />
            </linearGradient>
        </defs>
    </svg>

    <header>
        <div class="title">
            <div style="display:flex; align-items:center; gap:14px; position:relative;">

                <h1 style="margin:0;">Helldivers 2 Chaos Roulette</h1>

                <div style="display:flex; align-items:center; gap:10px; position:relative;">

                    <a href="https://www.youtube.com/@BootsOfTango"
                       target="_blank"
                       style="display:flex; align-items:center;">
                        <img src="youtube_logo.png.png"
                             alt="Boots Of Tango"
                             style="height:48px; width:auto; object-fit:contain; border-radius:8px; transition:0.2s;">
                    </a>

                    <div class="ytPromo">
                        <span class="arrow">➜</span>
                        Come to my channel for <strong>FUN</strong>  and  <strong>EPIC</strong>  Helldivers 2 videos!!
                    </div>

                </div>

            </div>

            <div class="sub">Solo only • D10 • equal chance chaos • one mission = one card</div>
        </div>
        <div class="pillRow">
            <div class="pill"><strong id="pillSaved">0</strong> saved</div>
            <div class="pill"><strong id="pillMode">—</strong> mode</div>
            <div class="pill"><strong id="pillFaction">—</strong> faction</div>
            <div class="pill yellow">Seed: <strong id="pillSeed">—</strong></div>
        </div>
    </header>

    <main>
        <div class="tabs">
            <div class="tabBtn active" data-tab="spin">SPIN</div>
            <div class="tabBtn" data-tab="results">RESULTS</div>
            <div class="tabBtn" data-tab="compare">COMPARE</div>
            <div class="tabBtn" data-tab="items">ITEMS</div>
            <div class="tabBtn" data-tab="rank">RANK</div>
        </div>

        <!-- SPIN TAB -->
        <section id="tab-spin" class="panel">
            <div class="btnRow">
                <button class="btnPrimary" id="btnSpin">SPIN LOADOUT</button>
                <button id="btnLock" class="btnGhost" disabled>LOCK LOADOUT</button>
                <button id="btnRollPlanet" class="btnGhost" disabled>ROLL PLANET</button>
                <button id="btnUse" class="btnPrimary" disabled>CONFIRM</button>
                <button id="btnReroll" class="btnDanger" style="display:none;">SPECIAL EVENT: REROLL (3)</button>

                <div class="pillRow" style="margin-left:auto;">
                    <div class="pill">D10 • <strong>Solo</strong></div>
                    <div class="pill">Cards: <strong id="spinSavedCount">0</strong></div>
                </div>
            </div>

            <div class="label">Spin reels</div>
            <div class="slotGrid" id="slotGrid">
                <div class="slotCol">
                    <div class="slotRow"><span class="slotTag">Primary</span><div class="slot slot-primary" id="slotPrimary">—</div></div>
                    <div class="slotRow"><span class="slotTag">Sidearm</span><div class="slot slot-sidearm" id="slotSidearm">—</div></div>
                    <div class="slotRow"><span class="slotTag">Throwable</span><div class="slot slot-throwable" id="slotThrowable">—</div></div>
                </div>
                <div class="slotCol">
                    <div class="slotRow"><span class="slotTag">Strat 1</span><div class="slot slot-strat" id="slotStrat1">—</div></div>
                    <div class="slotRow"><span class="slotTag">Strat 2</span><div class="slot slot-strat" id="slotStrat2">—</div></div>
                    <div class="slotRow"><span class="slotTag">Strat 3</span><div class="slot slot-strat" id="slotStrat3">—</div></div>
                    <div class="slotRow"><span class="slotTag">Strat 4</span><div class="slot slot-strat" id="slotStrat4">—</div></div>
                </div>
            </div>

            <div class="smallHelp">Reels spin in order and slow down on reveal (especially stratagems). Equal odds. Pure chaos.</div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="box">
                        <div class="label">Current Seed</div>
                        <div class="big" id="spinSeed">—</div>
                    </div>
                </div>

                <div class="col">
                    <div class="box">
                        <div class="label">Mode</div>
                        <div class="big" id="spinMode">—</div>
                        <div class="tiny">One mission per card. Blitz = 12 minutes. Standard = 40 minutes.</div>
                    </div>
                </div>


            </div>

            <div class="row" style="margin-top:12px;">
                <div class="col">
                    <div class="box">
                        <div class="label">Planet (rolled separately)</div>
                        <div class="big" id="dispPlanet">—</div>

                        <div id="planetInfoCards" class="planetCardWrap" style="margin-top:10px; display:none;"></div>

                        <div class="tiny" id="dispPlanetTiny" style="display:none;"></div>

                    </div>
                </div>
            </div>
        </section>

        <!-- RESULTS TAB -->
        <section id="tab-results" class="panel" style="display:none;">
            <div class="row">
                <div class="col">
                    <div class="label">Saved loadout cards</div>
                </div>
                <div class="col right">
                    <div class="miniRow" style="justify-content:flex-end;">
                        <button id="btnExport" class="btnGhost">EXPORT JSON</button>
                        <button id="btnImport" class="btnGhost">IMPORT JSON</button>
                        <input id="importFile" type="file" accept="application/json" style="display:none;" />
                        <button id="btnClearAll" class="btnDanger">CLEAR ALL DATA</button>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="label">Filter</div>
                    <div class="formGrid3">
                        <select id="resFilterMode">
                            <option value="">All modes</option>
                            <option value="Blitz (12)">Blitz (12)</option>
                            <option value="Standard (40)">Standard (40)</option>
                        </select>
                        <select id="resFilterFaction">
                            <option value="">All factions</option>
                            <option value="Terminids">Terminids</option>
                            <option value="Automatons">Automatons</option>
                            <option value="Illuminate">Illuminate</option>
                            <option value="Super Earth">Super Earth</option>
                        </select>
                        <select id="resSort">
                            <option value="new">Sort: newest</option>
                            <option value="old">Sort: oldest</option>
                            <option value="kills_desc">Kills (high → low)</option>
                            <option value="deaths_asc">Deaths (low → high)</option>
                            <option value="stims_asc">Stims (low → high)</option>
                            <option value="grade_desc">Grade (high → low)</option>
                        </select>
                    </div>
                    <div class="smallHelp">Cards only exist if you hit “USE THIS RUN” from SPIN. Because your viewers don’t care about your indecision.</div>
                </div>
            </div>

            <div id="resultsScroll">
                <div id="resultsGrid" class="cardGrid"></div>
            </div>
        </section>

        <!-- COMPARE TAB -->
        <section id="tab-compare" class="panel" style="display:none;">
            <div class="row">
                <div class="col">
                    <div class="label">Compare two cards</div>
                    <div class="formGrid">
                        <select id="cmpA"></select>
                        <select id="cmpB"></select>
                    </div>
                    <div class="smallHelp">Green = better. Red = worse. If you put garbage stats in, the comparison will reflect that. Shocking.</div>
                </div>
                <div class="col">
                    <div class="label">Sort & search</div>
                    <div class="formGrid3">
                        <select id="cmpSortMetric">
                            <option value="grade">Sort by Grade</option>
                            <option value="kills">Sort by Kills</option>
                            <option value="deaths">Sort by Deaths</option>
                            <option value="stims">Sort by Stims</option>
                        </select>
                        <select id="cmpSortDir">
                            <option value="desc">High → Low</option>
                            <option value="asc">Low → High</option>
                        </select>
                        <input id="cmpSearch" placeholder="Search by seed, weapon, strat, planet..." />
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="label">Comparison</div>
                    <table class="cmpTable" id="cmpTable"></table>
                </div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="label">Radar comparison</div>
                    <div class="radarCompareWrap">
                        <div class="cmpRadarRow">
                            <div id="cmpRadarA" class="cmpRadar"></div>
                            <div id="cmpRadarB" class="cmpRadar"></div>
                        </div>
                        <div class="miniRow" style="justify-content:center;">
                            <button id="btnOverlayRadar" class="btnPrimary" disabled>STACK RADARS</button>
                        </div>
                        <div id="cmpRadarOverlay" class="cmpRadarOverlay"></div>
                        <div id="cmpInsight" class="smallHelp"></div>
                    </div>


                </div>
            </div>
        </section>

        <!-- ITEMS TAB -->
        <section id="tab-items" class="panel" style="display:none;">
            <div class="row">
                <div class="col">
                    <div class="label">Edit your item pools (enable/disable, add/remove)</div>
                    <div class="smallHelp">Everything is equal chance among ENABLED items only. Disable what you don’t own. Add new warbond stuff. The roulette does not care.</div>
                </div>
                <div class="col right">
                    <div class="miniRow" style="justify-content:flex-end;">
                        <button id="btnResetDefaults" class="btnDanger">RESET DEFAULT LISTS</button>
                        <button id="btnSaveItems" class="btnPrimary">SAVE ITEMS</button>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="label">Primary</div>
                    <div id="listPrimaries"></div>
                    <div class="miniRow" style="margin-top:10px;">
                        <input id="addPrimary" placeholder="Add primary..." />
                        <button id="btnAddPrimary" class="btnGhost">ADD</button>
                    </div>
                </div>
                <div class="col">
                    <div class="label">Sidearm</div>
                    <div id="listSidearms"></div>
                    <div class="miniRow" style="margin-top:10px;">
                        <input id="addSidearm" placeholder="Add sidearm..." />
                        <button id="btnAddSidearm" class="btnGhost">ADD</button>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="label">Throwable</div>
                    <div id="listThrowables"></div>
                    <div class="miniRow" style="margin-top:10px;">
                        <input id="addThrowable" placeholder="Add throwable..." />
                        <button id="btnAddThrowable" class="btnGhost">ADD</button>
                    </div>
                </div>
                <div class="col">
                    <div class="label">Stratagems</div>
                    <div id="listStrats"></div>
                    <div class="miniRow" style="margin-top:10px;">
                        <input id="addStrat" placeholder="Add stratagem..." />
                        <button id="btnAddStrat" class="btnGhost">ADD</button>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="row">
                <div class="col">
                    <div class="label">Planets & sectors (edit freely)</div>
                    <div class="smallHelp">Planet roll uses this list. Each planet must have: faction, sector, weather tags (comma separated).</div>
                    <div id="listPlanets"></div>

                    <div class="hr"></div>

                    <div class="formGrid3">
                        <input id="pName" placeholder="Planet name" />
                        <select id="pFaction">
                            <option value="Terminids">Terminids</option>
                            <option value="Automatons">Automatons</option>
                            <option value="Illuminate">Illuminate</option>
                            <option value="Super Earth">Super Earth</option>
                        </select>
                        <input id="pSector" placeholder="Sector (e.g. Orion Sector)" />
                    </div>
                    <div class="formGrid" style="margin-top:10px;">
                        <input id="pWeather" placeholder="Weather tags (comma) e.g. snowy, acid, volcanic" />
                        <button id="btnAddPlanet" class="btnGhost">ADD PLANET</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- RANK TAB -->
        <section id="tab-rank" class="panel" style="display:none;">
            <div class="row">
                <div class="col">
                    <div class="label">Rank system</div>
                    <div class="tiny">
                        Each card gets a <strong>raw score</strong> from your recorded stats, then everything is scaled so the top run is always <strong>100</strong>.
                        <br><br>
                        <strong>Raw Score</strong> (default, tweakable later):
                        <br>
                        <br>
                        (clamped to 0 so nobody gets “negative liberty”)
                    </div>
                </div>
                <div class="col right">
                    <button id="btnRecalcRanks" class="btnPrimary">RECALCULATE</button>
                </div>
            </div>

            <div class="divider"></div>

            <div id="rankList"></div>
            <div class="smallHelp">Top 3 rims: shiny white (1), gold (2), silver (3). Bronze for 4th. The rest: default. Humans love medals.</div>
        </section>

    </main>

    <script>
        let WIRED_ONCE = false;
        function wireOnce() {
            if (WIRED_ONCE) return;
            WIRED_ONCE = true;
            wire();
        }


        let audioCtx = null;

        function getAudioCtx() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx;
        }

        function playTone(type = "tick") {
            try {
                const ctx = getAudioCtx();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                if (type === "tick") {
                    osc.frequency.value = 800;
                    gain.gain.value = 0.03;
                    osc.start();
                    osc.stop(ctx.currentTime + 0.05);
                }

                if (type === "final") {
                    osc.frequency.value = 400;
                    gain.gain.value = 0.08;
                    osc.start();
                    osc.stop(ctx.currentTime + 0.18);
                }

                if (type === "success") {
                    osc.type = "triangle";
                    osc.frequency.value = 600;
                    gain.gain.value = 0.1;
                    osc.start();
                    osc.stop(ctx.currentTime + 0.25);
                }

            } catch (e) { }
        }
        const $ = (sel) => document.querySelector(sel);
        const $$ = (sel) => Array.from(document.querySelectorAll(sel));
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const nowISO = () => new Date().toISOString();
        const randInt = (n) => Math.floor(Math.random() * n);

        /* ===== COMPARE RENDER STATE LOCK ===== */
        let cmpRadarReadyA = false;
        let cmpRadarReadyB = false;

        function tryEnableOverlay() {
            const btn = document.querySelector("#btnOverlayRadar");
            if (!btn) return;
            btn.disabled = !(cmpRadarReadyA && cmpRadarReadyB);
        }


        function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

        /* ===== APP BOOT (ENSURE BIOMES LOAD BEFORE PLANET ROLLS) ===== */
        async function initApp() {
            const btn = document.querySelector("#btnRollPlanet");
            if (btn) btn.disabled = true;

            // Kick off biome load, but do NOT block the app.
            // Biomes are a UI enhancement, not a dependency.
            loadBiomes();

            // Absolute fail-safe: unlock planet roll even if the biome API is slow/dead.
            setTimeout(() => {
                const b = document.querySelector("#btnRollPlanet");
                if (b) b.disabled = false;
            }, 1200);
        }




        function uid() {
            return Math.random().toString(16).slice(2) + "-" + Date.now().toString(16);
        }


        function normalizePlanetKey(name) {
            return String(name || "")
                .toLowerCase()
                .replace(/[^a-z0-9]/g, "")
                .trim();
        }
        /* =========================================================
        LOCAL PLANET BIOME DATABASE
        Single Source Of Truth
        ========================================================= */

        const LOCAL_PLANET_DATA = [
            { name: "SUPER EARTH", biome: "Super Earth", hazard: "NONE" },
            { name: "KLEN DAHTH II", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "PATHFINDER V", biome: "Plains", hazard: "NONE" },
            { name: "WIDOW'S HARBOR", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "NEW HAVEN", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "PILEN V", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "HYDROFALL PRIME", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "ZEA RUGOSIA", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "DARROWSPORT", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "FORNSKOGUR II", biome: "Basic Swamp", hazard: "NONE" },
            { name: "MIDASBURG", biome: "Tundra", hazard: "NONE" },
            { name: "CERBERUS IIIc", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "PROSPERITY FALLS", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "OKUL VI", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "MARTYR'S BAY", biome: "Boneyard", hazard: "NONE" },
            { name: "FREEDOM PEAK", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "FORT UNION", biome: "Plains", hazard: "NONE" },
            { name: "KELVINOR", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "WRAITH", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "IGLA", biome: "Boneyard", hazard: "NONE" },
            { name: "NEW KIRUNA", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "FORT JUSTICE", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "ZEGEMA PARADISE", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "PROVIDENCE", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "PRIMORDIA", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "SULFURA", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "NUBLARIA I", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "KRAKATWO", biome: "Boneyard", hazard: "NONE" },
            { name: "VOLTERRA", biome: "Plains", hazard: "NONE" },
            { name: "CRUCIBLE", biome: "Tundra", hazard: "NONE" },
            { name: "VEIL", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "MARRE IV", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "FORT SANCTUARY", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "SEYSHEL BEACH", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "HELLMIRE", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "EFFLUVIA", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "SOLGHAST", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "DILUVIA", biome: "Tundra", hazard: "NONE" },
            { name: "VIRIDIA PRIME", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "OBARI", biome: "Plains", hazard: "NONE" },
            { name: "MYRADESH", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "ATRAMA", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "EMERIA", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "BARABOS", biome: "Basic Swamp", hazard: "NONE" },
            { name: "FENMIRE", biome: "Plains", hazard: "NONE" },
            { name: "MASTIA", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "SHALLUS", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "KRAKABOS", biome: "Basic Swamp", hazard: "NONE" },
            { name: "IRIDICA", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "AZTERRA", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "AZUR SECUNDUS", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "IVIS", biome: "Basic Swamp", hazard: "NONE" },
            { name: "SLIF", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "CARAMOOR", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "KHARST", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "EUKORIA", biome: "Boneyard", hazard: "NONE" },
            { name: "MYRIUM", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "KERTH SECUNDUS", biome: "Tundra", hazard: "NONE" },
            { name: "PARSH", biome: "Basic Swamp", hazard: "NONE" },
            { name: "REAF", biome: "Plains", hazard: "NONE" },
            { name: "IRULTA", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "EMORATH", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "ILDUNA PRIME", biome: "Tundra", hazard: "NONE" },
            { name: "MAW", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "MERIDIA", biome: "Supercolony", hazard: "NONE" },
            { name: "BOREA", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "CURIA", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "TARSH", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "SHELT", biome: "Tundra", hazard: "NONE" },
            { name: "IMBER", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "BLISTICA", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "RATCH", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "JULHEIM", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "VALGAARD", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "ARKTURUS", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "ESKER", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "TERREK", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "CIRRUS", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "CRIMSICA", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "HEETH", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "VELD", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "ALTA V", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "URSICA XI", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "INARI", biome: "Boneyard", hazard: "NONE" },
            { name: "SKAASH", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "MORADESH", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "RASP", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "BASHYR", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "REGNUS", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "MOG", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "VALMOX", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "IRO", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "GRAFMERE", biome: "Boneyard", hazard: "NONE" },
            { name: "NEW STOCKHOLM", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "OASIS", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "GENESIS PRIME", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "OUTPOST 32", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "CALYPSO", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "ELYSIAN MEADOWS", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "ALDERIDGE COVE", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "TRANDOR", biome: "Tundra", hazard: "NONE" },
            { name: "EAST IRIDIUM TRADING BAY", biome: "Basic Swamp", hazard: "NONE" },
            { name: "LIBERTY RIDGE", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "BALDRICK PRIME", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "THE WEIR", biome: "Plains", hazard: "NONE" },
            { name: "KUPER", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "OSLO STATION", biome: "Boneyard", hazard: "NONE" },
            { name: "PÖPLI IX", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "GUNVALD", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "DOLPH", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "BEKVAM III", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "DUMA TYR", biome: "Tundra", hazard: "NONE" },
            { name: "VERNEN WELLS", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "AESIR PASS", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "AURORA BAY", biome: "Tundra", hazard: "NONE" },
            { name: "PENTA", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "GAELLIVARE", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "VOG-SOJOTH", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "KIRRIK", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "MORTAX PRIME", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "WILFORD STATION", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "PIONEER II", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "ERSON SANDS", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "SOCORRO III", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "BORE ROCK", biome: "Basic Swamp", hazard: "NONE" },
            { name: "FENRIR III", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "TURING", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "ANGEL'S VENTURE", biome: "Tundra", hazard: "NONE" },
            { name: "DARIUS II", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "ACAMAR IV", biome: "Plains", hazard: "NONE" },
            { name: "ACHERNAR SECUNDUS", biome: "Plains", hazard: "NONE" },
            { name: "ACHIRD III", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "ACRAB XI", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "ACRUX IX", biome: "Boneyard", hazard: "NONE" },
            { name: "ACUBENS PRIME", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "ADHARA", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "AFOYAY BAY", biome: "Plains", hazard: "NONE" },
            { name: "AIN-5", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "ALAIRT III", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "ALAMAK VII", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "ALARAPH", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "ALATHFAR XI", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "ANDAR", biome: "Tundra", hazard: "NONE" },
            { name: "ASPEROTH PRIME", biome: "Basic Swamp", hazard: "NONE" },
            { name: "BELLATRIX", biome: "Plains", hazard: "NONE" },
            { name: "BOTEIN", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "OSUPSAM", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "BRINK-2", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "BUNDA SECUNDUS", biome: "Tundra", hazard: "NONE" },
            { name: "CANOPUS", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "CAPH", biome: "Basic Swamp", hazard: "NONE" },
            { name: "CASTOR", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "DURGEN", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "DRAUPNIR", biome: "Plains", hazard: "NONE" },
            { name: "MORT", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "INGMAR", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "CHARBAL-VII", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "CHARON PRIME", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "CHOEPESSA IV", biome: "Boneyard", hazard: "NONE" },
            { name: "CHOOHE", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "CHORT BAY", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "CLAORELL", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "CLASA", biome: "Basic Swamp", hazard: "NONE" },
            { name: "DEMIURG", biome: "Tundra", hazard: "NONE" },
            { name: "DENEB SECUNDUS", biome: "Boneyard", hazard: "NONE" },
            { name: "ELECTRA BAY", biome: "Plains", hazard: "NONE" },
            { name: "ENULIALE", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "EPSILON PHOENCIS VI", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "ERATA PRIME", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "ESTANU", biome: "Boneyard", hazard: "NONE" },
            { name: "FORI PRIME", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "GACRUX", biome: "Basic Swamp", hazard: "NONE" },
            { name: "GAR HAREN", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "GATRIA", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "GEMMA", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "GRAND ERRANT", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "HADAR", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "HAKA", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "HALDUS", biome: "Basic Swamp", hazard: "NONE" },
            { name: "HALIES PORT", biome: "Boneyard", hazard: "NONE" },
            { name: "HERTHON SECUNDUS", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "HESOE PRIME", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "HEZE BAY", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "HORT", biome: "Plains", hazard: "NONE" },
            { name: "HYDROBIUS", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "KARLIA", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "KEID", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "KHANDARK", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "KLAKA 5", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "KNETH PORT", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "KRAZ", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "KUMA", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "LASTOFE", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "LENG SECUNDUS", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "LESATH", biome: "Boneyard", hazard: "NONE" },
            { name: "MAIA", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "MALEVELON CREEK", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "MANTES", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "MARFARK", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "MARTALE", biome: "Tundra", hazard: "NONE" },
            { name: "MATAR BAY", biome: "Plains", hazard: "NONE" },
            { name: "MEISSA", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "MEKBUDA", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "MENKENT", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "MERAK", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "MERGA IV", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "MINCHIR", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "MINTORIA", biome: "Plains", hazard: "NONE" },
            { name: "MORDIA 9", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "NABATEA SECUNDUS", biome: "Basic Swamp", hazard: "NONE" },
            { name: "NAVI VII", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "NIVEL 43", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "OSHAUNE", biome: "Hive World", hazard: "NONE" },
            { name: "OVERGOE PRIME", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "PANDION-XXIV", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "PARTION", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "PEACOCK", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "PHACT BAY", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "PHERKAD SECUNDUS", biome: "Basic Swamp", hazard: "NONE" },
            { name: "POLARIS PRIME", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "POLLUX 31", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "PRASA", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "PROPUS", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "RAS ALGETHI", biome: "Tundra", hazard: "NONE" },
            { name: "RD-4", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "ROGUE 5", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "RIRGA BAY", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "SEASSE", biome: "Basic Swamp", hazard: "NONE" },
            { name: "SENGE 23", biome: "Rocky Canyons", hazard: "TREMORS" },
            { name: "SETIA", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "SHETE", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "SIEMNOT", biome: "Ionic Jungle", hazard: "ION STORMS" },
            { name: "SIRIUS", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "SKAT BAY", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "SPHERION", biome: "Volcanic Jungle", hazard: "VOLCANIC ACTIVITY" },
            { name: "STOR THA PRIME", biome: "Boneyard", hazard: "NONE" },
            { name: "STOUT", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "TERMADON", biome: "Plains", hazard: "NONE" },
            { name: "TIBIT", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "TIEN KWAN", biome: "Boneyard", hazard: "METEOR STORMS" },
            { name: "TROOST", biome: "Deadlands", hazard: "THICK FOG" },
            { name: "UBANEA", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "USTOTU", biome: "Desert Cliffs", hazard: "TREMORS" },
            { name: "VANDALON IV", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "VARYLIA 5", biome: "Plains", hazard: "NONE" },
            { name: "WASAT", biome: "Acidic Badlands", hazard: "ACID STORMS" },
            { name: "VEGA BAY", biome: "Icy Glaciers", hazard: "BLIZZARDS" },
            { name: "WEZEN", biome: "Scorched Moor", hazard: "FIRE TORNADOES" },
            { name: "VINDEMITARIX PRIME", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "X-45", biome: "Basic Swamp", hazard: "NONE" },
            { name: "YED PRIOR", biome: "Ionic Crimson", hazard: "ION STORMS" },
            { name: "ZEFIA", biome: "Ethereal Jungle", hazard: "NONE" },
            { name: "ZOSMA", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "ZZANIAH PRIME", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "SKITTER", biome: "Haunted Swamp", hazard: "THICK FOG" },
            { name: "EUPHORIA III", biome: "Moon", hazard: "METEOR STORMS" },
            { name: "DIASPORA X", biome: "Desert Dunes", hazard: "SANDSTORMS" },
            { name: "GEMSTONE BLUFFS", biome: "Plains", hazard: "NONE" },
            { name: "ZAGON PRIME", biome: "Hive World", hazard: "NONE" },
            { name: "OMICRON", biome: "Hive World", hazard: "NONE" },
            { name: "CYBERSTAN", biome: "Boneyard", hazard: "NONE" },
            { name: "FURY", biome: "Magma", hazard: "NONE" },
            { name: "K", biome: "Magma", hazard: "NONE" },
            { name: "Mox", biome: "Magma", hazard: "NONE" },
        ];
        function getPlanetBiomeFromPlanet(p) {
            // Priority:
            // 1) Explicit biome on the planet object (best case)
            // 2) Internal planet database (state.items.planets) by name
            // 3) Local biome TXT map (LOCAL_PLANET_BIOME_MAP) if loaded
            // 4) Crosswave map (PLANET_BIOME_MAP) if loaded
            // 5) LOCAL_PLANET_DATA hardcoded fallback table
            // 6) Fallback to environment/weather
            const direct = (p && typeof p.biome === "string") ? p.biome.trim() : "";
            if (direct && direct !== "—" && direct.toLowerCase() !== "unknown") return direct;

            const name = (p && (p.name || p.planet || p.planetName || p.displayName)) || "";
            const key = normalizePlanetKey(name);

            // Internal planet DB (the big list in DEFAULTS / ITEMS tab)
            try {
                const db = (state && state.items && Array.isArray(state.items.planets)) ? state.items.planets : [];
                const hit = db.find(x => normalizePlanetKey(x && x.name) === key);
                const b = (hit && typeof hit.biome === "string") ? hit.biome.trim() : "";
                if (b) return b;
            } catch (e) { }

            // Local TXT biome map (loaded via fetch/file input)
            try {
                if (key && LOCAL_PLANET_BIOME_MAP && LOCAL_PLANET_BIOME_MAP[key]) return LOCAL_PLANET_BIOME_MAP[key];
            } catch (e) { }

            // Crosswave biome map (network)
            try {
                if (key && PLANET_BIOME_MAP && PLANET_BIOME_MAP[key]) return PLANET_BIOME_MAP[key];
            } catch (e) { }

            // Hardcoded fallback list
            try {
                if (key && Array.isArray(LOCAL_PLANET_DATA)) {
                    const hit2 = LOCAL_PLANET_DATA.find(x => normalizePlanetKey(x && x.name) === key);
                    const b2 = (hit2 && typeof hit2.biome === "string") ? hit2.biome.trim() : "";
                    if (b2) return b2;
                }
            } catch (e) { }

            return (
                (p && p.environment) ||
                (p && p.weather) ||
                "—"
            );
        }

function normalizeText(s) { return String(s || "").toLowerCase().trim(); }

        // Canonicalize faction names so filters/colors don't silently fail.
        function normalizeFactionName(f) {
            const s = String(f || "").trim();
            if (!s) return "";
            const low = s.toLowerCase();

            if (low === "automaton" || low === "automatons") return "Automatons";
            if (low === "terminid" || low === "terminids") return "Terminids";
            if (low === "illuminate" || low === "illuminates") return "Illuminate";
            if (low === "super earth" || low === "superearth" || low === "super_earth") return "Super Earth";

            // Keep unknown values as-is (better than losing data)
            return s;
        }

        function sanitizeFactionData() {
            // Planets
            if (state?.items?.planets) {
                for (const p of state.items.planets) {
                    if (!p) continue;
                    p.faction = normalizeFactionName(p.faction);
                }
            }
            // Saved cards
            if (state?.cards) {
                for (const c of state.cards) {
                    if (!c) continue;
                    if ("faction" in c) c.faction = normalizeFactionName(c.faction);
                    if (c.planet && "faction" in c.planet) c.planet.faction = normalizeFactionName(c.planet.faction);
                }
            }
        }


        // Turns whatever the API / data gives us into a clean, human-readable weather string.
        // This is intentionally tolerant: APIs love changing shapes.
        function envToWeather(env) {
            // If someone already stringified objects, don't propagate that poison.
            if (typeof env === "string" && env.includes("[object Object]")) return "None";

            const out = [];
            const seen = new Set();

            function pushIfText(v) {
                const s = String(v ?? "").trim();
                if (!s) return;
                if (s === "—") return;
                if (s.toLowerCase() === "none") return;
                if (s === "[object Object]") return;
                const key = s.toLowerCase();
                if (seen.has(key)) return;
                seen.add(key);
                out.push(s);
            }

            function extractDeep(v, depth) {
                if (v == null) return;
                if (depth > 6) return;

                if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
                    pushIfText(v);
                    return;
                }

                if (Array.isArray(v)) {
                    for (const x of v) extractDeep(x, depth + 1);
                    return;
                }

                if (typeof v === "object") {
                    const keys = ["weather", "weatherText", "environment", "env", "name", "label", "type", "biome", "tags", "effects", "modifiers", "environmentals", "environmentalConditions"];
                    for (const k of keys) {
                        if (k in v) extractDeep(v[k], depth + 1);
                    }
                    for (const x of Object.values(v)) extractDeep(x, depth + 1);
                }
            }

            extractDeep(env, 0);
            return out.length ? out.join("; ") : "None";
        }

        function getPlanetWeatherText(planet) {
            if (!planet) return "None";
            const wt = planet.weatherText;
            if (typeof wt === "string" && wt.trim()) return wt.trim();
            return envToWeather(planet.weather || planet.environment || planet.env || planet.modifiers || planet.effects);
        }

        /* ===== BIOME RESOLUTION (API + LOCAL) ===== */
        let BIOME_LOOKUP = {};
        let BIOMES_READY = false;

        async function loadBiomes() {
            try {
                BIOMES_READY = true;
            } catch (e) { }
            finally {
                const b = document.querySelector("#btnRollPlanet");
                if (b) b.disabled = false;
            }
        }


        function getPlanetBiomeFromPlanet(p) {
            // Priority:
            // 1) Explicit biome on the planet object (best case)
            // 2) Internal planet database (state.items.planets) by name
            // 3) Local biome TXT map (LOCAL_PLANET_BIOME_MAP) if loaded
            // 4) Crosswave map (PLANET_BIOME_MAP) if loaded
            // 5) LOCAL_PLANET_DATA hardcoded fallback table
            // 6) Fallback to environment/weather
            const direct = (p && typeof p.biome === "string") ? p.biome.trim() : "";
            if (direct && direct !== "—" && direct.toLowerCase() !== "unknown") return direct;

            const name = (p && (p.name || p.planet || p.planetName || p.displayName)) || "";
            const key = normalizePlanetKey(name);

            // Internal planet DB (the big list in DEFAULTS / ITEMS tab)
            try {
                const db = (state && state.items && Array.isArray(state.items.planets)) ? state.items.planets : [];
                const hit = db.find(x => normalizePlanetKey(x && x.name) === key);
                const b = (hit && typeof hit.biome === "string") ? hit.biome.trim() : "";
                if (b) return b;
            } catch (e) { }

            // Local TXT biome map (loaded via fetch/file input)
            try {
                if (key && LOCAL_PLANET_BIOME_MAP && LOCAL_PLANET_BIOME_MAP[key]) return LOCAL_PLANET_BIOME_MAP[key];
            } catch (e) { }

            // Crosswave biome map (network)
            try {
                if (key && PLANET_BIOME_MAP && PLANET_BIOME_MAP[key]) return PLANET_BIOME_MAP[key];
            } catch (e) { }

            // Hardcoded fallback list
            try {
                if (key && Array.isArray(LOCAL_PLANET_DATA)) {
                    const hit2 = LOCAL_PLANET_DATA.find(x => normalizePlanetKey(x && x.name) === key);
                    const b2 = (hit2 && typeof hit2.biome === "string") ? hit2.biome.trim() : "";
                    if (b2) return b2;
                }
            } catch (e) { }

            return (
                (p && p.environment) ||
                (p && p.weather) ||
                "—"
            );
        }




        function splitWeatherTags(weatherStr) {
            const rejectObjectToken = (t) => t && !String(t).includes("[object Object]");
            const s = String(weatherStr || "").trim();
            if (!s || s === "—" || s.toLowerCase() === "none") return [];
            // Accept separators used across different sources: commas, semicolons, slashes, pipes
            return s.split(/[,;|\/]+/g).map(x => x.trim()).filter(Boolean);
        }

        function envEmoji(name) {
            const n = String(name || "").toLowerCase();
            if (n.includes("acid")) return "☣";
            if (n.includes("ion")) return "⚡";
            if (n.includes("fire")) return "🔥";
            if (n.includes("heat")) return "🔥";
            if (n.includes("fog")) return "🌫";
            if (n.includes("sand")) return "🌪";
            if (n.includes("storm")) return "⛈";
            if (n.includes("meteor")) return "☄";
            if (n.includes("quake") || n.includes("tremor")) return "🌋";
            if (n.includes("cold") || n.includes("blizzard")) return "❄";
            if (n.includes("rain")) return "🌧";
            return "🛰";
        }


        function download(filename, text) {
            const a = document.createElement("a");
            a.href = URL.createObjectURL(new Blob([text], { type: "application/json" }));
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(a.href), 500);
        }

        /***********************
         * Default data pools
         * (starter lists based on your screenshots)
         ***********************/
        const DEFAULTS = {
            seedWordsA: [
                "Liberty", "Freedom", "Democracy", "Justice", "Officer", "Citizen", "Patriot", "Helldiver", "SuperEarth", "Verdict",
                "Muscle", "Iron", "Titan", "Beacon", "Eagle", "Orbital", "Destroyer", "Ballot", "Duty", "Vanguard", "Frontline",
                "Courage", "Honor", "Steel", "Wrath", "Judgement", "Order", "Shield", "Flame", "Thunder", "Doctrine"
            ],
            seedWordsB: [
                "Madness", "Protocol", "Decree", "Manifest", "Judgement", "Crusade", "Ledger", "Gamble", "Reckoning", "March",
                "Cannon", "Strike", "Riot", "Mettle", "Oath", "Blitz", "Hammer", "Anvil", "Citizenry", "Purge", "Quota", "Dividend",
                "Reform", "Compliance", "Salute", "Ration", "Tax", "Boot", "Directive", "Glory", "Witness"
            ],

            items: {
                primaries: [
                    // Assault / general (from screenshot)
                    "AR-23 Liberator",
                    "AR-23P Liberator Penetrator",
                    "AR-23C Liberator Concussive",
                    "StA-52 Assault Rifle",
                    "AR-32 Pacifier",
                    "AR-2 Coyote",
                    "MA5C Assault Rifle",
                    "AR-23A Liberator Carbine",
                    "AR-61 Tenderizer",
                    "BR-14 Adjudicator",
                    "AR/GL-21 One-Two",
                    "AR-59 Suppressor",

                    // Marksman (from screenshot)
                    "R-2 Amendment",
                    "R-2124 Constitution",
                    "R-6 Deadeye",
                    "R-63 Diligence",
                    "R-63CS Diligence Counter Sniper",
                    "R-72 Censor",

                    // SMG (from screenshot)
                    "MP-98 Knight",
                    "StA-11 SMG",
                    "M7S SMG",
                    "SMG-32 Reprimand",
                    "SMG-37 Defender",
                    "SMG-72 Pummeler",

                    // Shotgun (from screenshot)
                    "SG-8 Punisher",
                    "SG-8S Slugger",
                    "SG-20 Halt",
                    "SG-451 Cookout",
                    "DBS-2 Double Freedom",
                    "M90A Shotgun",
                    "SG-225 Breaker",
                    "SG-225SP Breaker Spray&Pray",
                    "SG-225IE Breaker Incendiary",

                    // Explosive (from screenshot)
                    "CB-9 Exploding Crossbow",
                    "R-36 Eruptor",

                    // Energy-based (from screenshot)
                    "SG-8P Punisher Plasma",
                    "PLAS-39 Accelerator Rifle",
                    "ARC-12 Blitzer",
                    "LAS-5 Scythe",
                    "LAS-16 Sickle",
                    "LAS-17 Double-Edge Sickle",
                    "PLAS-1 Scorcher",
                    "PLAS-101 Purifier",
                    "LAS-13 Trident"
                ].map(n => ({ name: n, enabled: true })),

                sidearms: [
                    // Specials / sidearms (from screenshot)
                    "P-11 Stim Pistol",
                    "SG-22 Bushwhacker",
                    "LAS-58 Talon",
                    "P-72 Crisper",
                    "GP-31 Grenade Pistol",
                    "LAS-7 Dagger",
                    "GP-20 Ultimatum",
                    "PLAS-15 Loyalist",
                    "P-35 Re-Educator",

                    // Pistols (from screenshot)
                    "P-92 Warrant",
                    "P-2 Peacemaker",
                    "P-19 Redeemer",
                    "P-113 Verdict",
                    "M6C/SOCOM Pistol",
                    "P-4 Senator"
                ].map(n => ({ name: n, enabled: true })),

                throwables: [
                    // Special throwables (from screenshots)
                    "G-16 Impact",
                    "G-13 Incendiary Impact",
                    "G-23 Stun",
                    "G-4 Gas",
                    "G-50 Seeker",
                    "G-3 Smoke",
                    "G-123 Thermite",
                    "K-2 Throwing Knife",
                    "G-142 Pyrotech",
                    "G-109 Urchin",
                    "G-31 Arc",
                    "TM-1 Lure Mine",
                    "G-89 Smokescreen",
                    "G/SH-39 Shield",

                    // Standard throwables (from screenshot)
                    "TED-63 Dynamite",
                    "G-6 Frag",
                    "G-12 High Explosive",
                    "G-10 Incendiary",
                    "G-7 Pineapple"
                ].map(n => ({ name: n, enabled: true })),

                stratagems: [
                    // Support weapons screenshot
                    "GL-21 Grenade Launcher",
                    "LAS-98 Laser Cannon",
                    "ARC-3 Arc Thrower",
                    "LAS-99 Quasar Cannon",
                    "MG-43 Machine Gun",
                    "APW-1 Anti-Materiel Rifle",
                    "M-105 Stalwart",
                    "EAT-17 Expendable Anti-Tank",
                    "GR-8 Recoilless Rifle",
                    "FLAM-40 Flamethrower",
                    "AC-8 Autocannon",
                    "MG-206 Heavy Machine Gun",
                    "RL-77 Airburst Rocket Launcher",
                    "MLS-4X Commando",
                    "RS-422 Railgun",
                    "FAF-14 Spear",
                    "StA-X3 W.A.S.P. Launcher",

                    // Add more commonly used strats (starter pack; edit in ITEMS tab freely)
                    "Orbital Precision Strike",
                    "Orbital Laser",
                    "Orbital Railcannon Strike",
                    "Orbital Gatling Barrage",
                    "Orbital Airburst Strike",
                    "Orbital 120MM HE Barrage",
                    "Orbital 380MM HE Barrage",
                    "Orbital Smoke Strike",
                    "Eagle Airstrike",
                    "Eagle Cluster Bomb",
                    "Eagle Napalm Airstrike",
                    "Eagle Smoke Strike",
                    "Eagle 110MM Rocket Pods",
                    "Rocket Sentry",
                    "Gatling Sentry",
                    "Autocannon Sentry",
                    "Mortar Sentry",
                    "EMS Mortar Sentry",
                    "Shield Generator Relay",
                    "Ballistic Shield Backpack",
                    "Supply Pack",
                    "Jump Pack",
                    "Guard Dog Rover",
                    "Incendiary Mines",
                    "Anti-Personnel Minefield",
                    "EMS Strike",
                    "HMG Emplacement"
                ].map(n => ({ name: n, enabled: true })),

                planets: [

                    { name: "Alaraph", faction: "Super Earth", sector: "Akira Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Oasis", "Genesis Prime", "Alathfar XI", "Hydrobius"], regions: ["City – PERMACURIS", "City – HANGAR 6"] },

                    { name: "Alathfar XI", faction: "Super Earth", sector: "Akira Sector", biome: "Icy Glaciers", weather: "Extreme Cold; Blizzards", links: ["Alaraph", "Andar", "Karlia"], regions: ["City – UNNAMED", "Town – WORKSONG", "MegaCity – SEVERITY"] },

                    { name: "Asperoth Prime", faction: "Super Earth", sector: "Akira Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Khandark", "Andar", "Keid"], regions: ["City – ASPEN HILLS", "City – MEGACORPUS"] },

                    { name: "Keid", faction: "Super Earth", sector: "Akira Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Asperoth Prime", "Karlia", "Shete"], regions: [] },

                    { name: "Andar", faction: "Super Earth", sector: "Akira Sector", biome: "Tundra", weather: "None", links: ["Calypso", "Alathfar XI", "Asperoth Prime"], regions: ["MegaCity – NEW TOKYO"] },

                    { name: "Kraz", faction: "Super Earth", sector: "Alstrad Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Leng Secundus", "Bunda Secundus"], regions: [] },

                    { name: "Kneth Port", faction: "Super Earth", sector: "Alstrad Sector", biome: "Scorched Moor", weather: "Intense Heat; Fire Tornados", links: ["Brink-2", "Klaka 5", "Botein", "Spherion"], regions: [] },

                    { name: "Klaka 5", faction: "Super Earth", sector: "Alstrad Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Leng Secundus", "Osupsam", "Kneth Port"], regions: [] },

                    { name: "Pilen V", faction: "Super Earth", sector: "Altus Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: [], regions: [] },

                    { name: "New Haven", faction: "Super Earth", sector: "Altus Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Widow’s Harbor", faction: "Super Earth", sector: "Altus Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: [], regions: [] },

                    { name: "Klen Dahth II", faction: "Super Earth", sector: "Altus Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: [], regions: [] },

                    { name: "Pathfinder V", faction: "Super Earth", sector: "Altus Sector", biome: "Plains", weather: "Rainstorms", links: [], regions: [] },

                    { name: "Charbal-VII", faction: "Automaton", sector: "Andromeda Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Charon Prime", "Julheim", "Mort", "Choepessa IV"], regions: [] },

                    { name: "Charon Prime", faction: "Automaton", sector: "Andromeda Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Bekvam III", "Charbal-VII", "Choepessa IV", "Martale"], regions: [] },

                    { name: "Martale", faction: "Automaton", sector: "Andromeda Sector", biome: "Tundra", weather: "None", links: ["Charon Prime", "Marfark", "Matar Bay"], regions: ["Settlement – SONGGUO CUN", "City – XIN FUZHOU"] },

                    { name: "Matar Bay", faction: "Automaton", sector: "Andromeda Sector", biome: "Plains", weather: "Rainstorms", links: ["Marfark", "Choohe", "Martale", "Meissa"], regions: ["City – PARRHESIA", "Town – ISEGORIA"] },

                    { name: "Marfark", faction: "Automaton", sector: "Andromeda Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Bekvam III", "Aesir Pass", "Martale", "Matar Bay"], regions: [] },

                    { name: "Deneb Secundus", faction: "Super Earth", sector: "Arturion Sector", biome: "Boneyard", weather: "Extreme Cold", links: [], regions: [] },

                    { name: "Mortax Prime", faction: "Super Earth", sector: "Arturion Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: [], regions: [] },

                    { name: "Kirrik", faction: "Super Earth", sector: "Arturion Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: [], regions: [] },

                    { name: "Arkturus", faction: "Super Earth", sector: "Arturion Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: [], regions: [] },

                    { name: "Wilford Station", faction: "Super Earth", sector: "Arturion Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: [], regions: [] },

                    { name: "Pioneer II", faction: "Super Earth", sector: "Arturion Sector", biome: "Rocky Canyons", weather: "Tremors", links: [], regions: [] },

                    { name: "Electra Bay", faction: "Super Earth", sector: "Arturion Sector", biome: "Plains", weather: "Rainstorms", links: [], regions: [] },

                    { name: "Darrowsport", faction: "Super Earth", sector: "Barnard Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: [], regions: [] },

                    { name: "Fornskogur II", faction: "Super Earth", sector: "Barnard Sector", biome: "Basic Swamp", weather: "Rainstorms", links: [], regions: [] },

                    { name: "Hydrofall Prime", faction: "Super Earth", sector: "Barnard Sector", biome: "Rocky Canyons", weather: "Tremors", links: [], regions: [] },

                    { name: "Marre IV", faction: "Super Earth", sector: "Barnard Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: [], regions: [] },

                    { name: "Veil", faction: "Super Earth", sector: "Barnard Sector", biome: "Deadlands", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Midasburg", faction: "Super Earth", sector: "Barnard Sector", biome: "Tundra", weather: "None", links: [], regions: [] },

                    { name: "Ursica XI", faction: "Terminid", sector: "Borgus Sector", biome: "Ethereal Jungle", weather: "None", links: ["Achernar Secundus", "Inari", "Achird III"], regions: ["Town – NEW KATHMANDU", "City – PO’S RAVENNA"] },

                    { name: "Achird III", faction: "Terminid", sector: "Borgus Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Ursica XI", "Turing", "Darius II"], regions: ["Town – TIMELY", "City – APPROVAL CITY", "City – OLD BRANCH"] },

                    { name: "Darius II", faction: "Terminid", sector: "Borgus Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Achernar Secundus", "Achird III", "Phact Bay", "Acamar IV"], regions: ["City – BUJU"] },

                    { name: "Achernar Secundus", faction: "Terminid", sector: "Borgus Sector", biome: "Plains", weather: "Rainstorms", links: ["Gar Haren", "Ursica XI", "Darius II"], regions: ["Town – CURRENCY", "City – NEW NEWTONVILLE", "City – OL’ OLDHAM"] },

                    { name: "Fort Sanctuary", faction: "Super Earth", sector: "Cancri Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Seyshel Beach", "Eukoria"], regions: ["MegaCity – NEW YEARNING CITY"] },

                    { name: "Seyshel Beach", faction: "Super Earth", sector: "Cancri Sector", biome: "Ethereal Jungle", weather: "None", links: ["Effluvia", "Kerth Secundus", "Fort Sanctuary", "Myrium"], regions: ["Town – ACCOUNTANT GRAEBER", "Settlement – BEACHVIEW", "City – THE VILLAS", "MegaCity – NEW ALEXANDRIA"] },

                    { name: "Effluvia", faction: "Super Earth", sector: "Cancri Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Seyshel Beach", "Solghast", "Parsh"], regions: [] },

                    { name: "Cerberus IIIc", faction: "Super Earth", sector: "Cancri Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: [], regions: [] },

                    { name: "Prosperity Falls", faction: "Super Earth", sector: "Cancri Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Kelvinor", faction: "Super Earth", sector: "Cantolus Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: [], regions: [] },

                    { name: "Martyr’s Bay", faction: "Super Earth", sector: "Cantolus Sector", biome: "Boneyard", weather: "Extreme Cold", links: [], regions: [] },

                    { name: "Freedom Peak", faction: "Super Earth", sector: "Cantolus Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Viridia Prime", faction: "Super Earth", sector: "Cantolus Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Obari", "Emorath", "Diluvia"], regions: [] },

                    { name: "Obari", faction: "Super Earth", sector: "Cantolus Sector", biome: "Plains", weather: "Rainstorms", links: ["Baldrick Prime", "Viridia Prime"], regions: [] },

                    { name: "Meridia", faction: "Super Earth", sector: "Celeste Sector", biome: "Supercolony", weather: "None", links: [], regions: [] },

                    { name: "Slif", faction: "Super Earth", sector: "Celeste Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Alta V", "Krakatwo", "Volterra", "Veld"], regions: [] },

                    { name: "Moradesh", faction: "Super Earth", sector: "Celeste Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: [], regions: [] },

                    { name: "Ivis", faction: "Super Earth", sector: "Celeste Sector", biome: "Basic Swamp", weather: "Rainstorms", links: [], regions: [] },

                    { name: "Krakatwo", faction: "Super Earth", sector: "Celeste Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Nublaria I", "Slif", "Crucible"], regions: [] },

                    { name: "Nublaria I", faction: "Super Earth", sector: "Celeste Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Fort Union", "Sulfura", "Krakatwo"], regions: [] },

                    { name: "Sulfura", faction: "Super Earth", sector: "Celeste Sector", biome: "Ethereal Jungle", weather: "None", links: ["Nublaria I", "Azterra"], regions: [] },

                    { name: "Crimsica", faction: "Super Earth", sector: "Draco Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Acamar IV", "Estanu", "Fori Prime"], regions: ["Settlement – LIL’OME", "City – LLANFAIRPWLLGWYNGYLLGOGERYCHWYRNDROBWLLLLANTYSILIOGOGOGOCH II"] },

                    { name: "Estanu", faction: "Super Earth", sector: "Draco Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Hellmire", "Crimsica", "Fori Prime"], regions: [] },

                    { name: "Fori Prime", faction: "Terminid", sector: "Draco Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Crimsica", "Estanu", "Gacrux", "Oshaune"], regions: [] },

                    { name: "Bore Rock", faction: "Terminid", sector: "Falstaff Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Esker", "Terrek", "Erata Prime"], regions: [] },

                    { name: "Esker", faction: "Terminid", sector: "Falstaff Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Nivel 43", "Erson Sands", "Socorro III", "Bore Rock"], regions: [] },

                    { name: "Socorro III", faction: "Terminid", sector: "Falstaff Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Esker", "Erson Sands"], regions: [] },

                    { name: "Erson Sands", faction: "Terminid", sector: "Falstaff Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: ["Esker", "Socorro III", "Nivel 43"], regions: [] },

                    { name: "Pollux 31", faction: "Super Earth", sector: "Farsight Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Polaris Prime", "Prasa"], regions: [] },

                    { name: "Prasa", faction: "Super Earth", sector: "Farsight Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Pollux 31"], regions: ["Town – HANDAKAS", "City – HAKU CITY"] },

                    { name: "Grand Errant", faction: "Terminid", sector: "Farsight Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Gar Haren", "Pherkad Secundus", "Polaris Prime"], regions: [] },

                    { name: "Polaris Prime", faction: "Super Earth", sector: "Farsight Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: ["Grand Errant", "Pherkad Secundus", "Pollux 31"], regions: ["City – VILHELMINA DOROTHEA FREDRIKA", "Town – MOGO PLAINS", "City – KALASATAMA PORT"] },

                    { name: "Pherkad Secundus", faction: "Super Earth", sector: "Farsight Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Gatria", "Grand Errant", "Polaris Prime"], regions: [] },

                    { name: "Zea Rugosia", faction: "Illuminate", sector: "Ferris Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: ["Afoyay Bay", "Herthon Secundus", "Haldus"], regions: ["Town – NEW COB", "Settlement – GENE", "City – STARPASS"] },

                    { name: "Herthon Secundus", faction: "Illuminate", sector: "Ferris Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Ain-5", "Alairt III", "Zea Rugosia", "Hort"], regions: ["Town – PENSCEWT", "Town – EAGLE’S LIKENESS", "City – CONSENSUS"] },

                    { name: "Hadar", faction: "Super Earth", sector: "Ferris Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: [], regions: [] },

                    { name: "Haldus", faction: "Illuminate", sector: "Ferris Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Zea Rugosia", "Adhara"], regions: [] },

                    { name: "Kharst", faction: "Super Earth", sector: "Gallux Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Bashyr", faction: "Super Earth", sector: "Gallux Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Rasp", faction: "Super Earth", sector: "Gallux Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: [], regions: [] },

                    { name: "Acubens Prime", faction: "Super Earth", sector: "Gallux Sector", biome: "Ethereal Jungle", weather: "None", links: [], regions: [] },

                    { name: "Adhara", faction: "Super Earth", sector: "Gallux Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Haldus", "Mog", "Afoyay Bay"], regions: ["Settlement – TRAITOR’S END", "City – STRENGTH"] },

                    { name: "Afoyay Bay", faction: "Super Earth", sector: "Gallux Sector", biome: "Plains", weather: "Rainstorms", links: ["Adhara", "Zea Rugosia", "Valmox", "Ain-5"], regions: [] },

                    { name: "Minchir", faction: "Super Earth", sector: "Gellert Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Mintoria", faction: "Super Earth", sector: "Gellert Sector", biome: "Plains", weather: "Rainstorms", links: ["Blistica", "Zzaniah Prime", "Zefia"], regions: ["Settlement – SEORAKSAN", "Town – GYEONGSEONG"] },

                    { name: "Zzaniah Prime", faction: "Automaton", sector: "Gellert Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Blistica", "Zosma", "Mintoria"], regions: [] },

                    { name: "Zosma", faction: "Automaton", sector: "Gellert Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Zzaniah Prime"], regions: [] },

                    { name: "Blistica", faction: "Automaton", sector: "Gellert Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Yed Prior", "Mintoria", "Zzaniah Prime"], regions: [] },

                    { name: "Okul VI", faction: "Super Earth", sector: "Gothmar Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: [], regions: [] },

                    { name: "Solghast", faction: "Super Earth", sector: "Gothmar Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Effluvia", "Diluvia", "Reaf"], regions: ["Settlement – LUXE POINT", "Town – SHADY OAKS", "City – DOSTOINSTVO"] },

                    { name: "Diluvia", faction: "Super Earth", sector: "Gothmar Sector", biome: "Tundra", weather: "None", links: ["Solghast", "Viridia Prime", "Irulta"], regions: ["Town – GRACIOUS LIBERTY", "City – LUSCIOUS LIBERTY", "City – COUNCILLOR RORA"] },

                    { name: "Bellatrix", faction: "Super Earth", sector: "Guang Sector", biome: "Plains", weather: "Rainstorms", links: ["Alderidge Cove", "Khandark"], regions: [] },

                    { name: "Elysian Meadows", faction: "Illuminate", sector: "Guang Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Irulta", "Calypso", "East Iridium Trading Bay"], regions: [] },

                    { name: "Alderidge Cove", faction: "Super Earth", sector: "Guang Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Calypso", "Botein", "Bellatrix"], regions: [] },

                    { name: "Botein", faction: "Super Earth", sector: "Guang Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Alderidge Cove", "Kneth Port", "Khandark"], regions: [] },

                    { name: "Khandark", faction: "Super Earth", sector: "Guang Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Bellatrix", "Botein", "Asperoth Prime", "Skat Bay"], regions: [] },

                    { name: "Alairt III", faction: "Super Earth", sector: "Hanzo Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: ["Heze Bay", "New Stockholm", "Alamak VII", "Herthon Secundus"], regions: ["Town – GREATER STOROUSE", "Town – NEW STOROUSE", "Town – SHED", "MegaCity – FREE TRADE"] },

                    { name: "Alamak VII", faction: "Illuminate", sector: "Hanzo Sector", biome: "Ethereal Jungle", weather: "None", links: ["Oasis", "Alairt III", "New Stockholm"], regions: ["Town – KESUMA", "City – UNGU", "Settlement – NO COMPOUND", "MegaCity – FILIBUSTER"] },

                    { name: "New Stockholm", faction: "Illuminate", sector: "Hanzo Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Iro", "Ain-5", "Alairt III", "Alamak VII"], regions: [] },

                    { name: "Ain-5", faction: "Super Earth", sector: "Hanzo Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Afoyay Bay", "New Stockholm", "Herthon Secundus"], regions: [] },

                    { name: "Heze Bay", faction: "Illuminate", sector: "Hanzo Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Hydrobius", "Alairt III", "Rirga Bay"], regions: ["City – UNANIMITY", "City – UNISON"] },

                    { name: "Euphoria III", faction: "Super Earth", sector: "Hawking Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: [], regions: [] },

                    { name: "Kuma", faction: "Super Earth", sector: "Hawking Sector", biome: "Rocky Canyons", weather: "Tremors", links: [], regions: [] },

                    { name: "Mordia 9", faction: "Super Earth", sector: "Hawking Sector", biome: "Ethereal Jungle", weather: "None", links: [], regions: [] },

                    { name: "Skitter", faction: "Super Earth", sector: "Hawking Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Aesir Pass", faction: "Automaton", sector: "Hydra Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Curia", "Vernen Wells", "Marfark"], regions: [] },

                    { name: "Vernen Wells", faction: "Automaton", sector: "Hydra Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Menkent", "Tarsh", "Aesir Pass", "Lesath"], regions: ["Settlement – BLACKVEIN MINES", "Town – BENEVOLENCE", "Town – ANNE’S VIGIL"] },

                    { name: "Menkent", faction: "Automaton", sector: "Hydra Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Choohe", "Vernen Wells", "Chort Bay", "Lesath"], regions: [] },

                    { name: "Wraith", faction: "Super Earth", sector: "Idun Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: [], regions: [] },

                    { name: "Atrama", faction: "Super Earth", sector: "Idun Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Myradesh", faction: "Super Earth", sector: "Idun Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: [], regions: [] },

                    { name: "Maw", faction: "Super Earth", sector: "Idun Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: [], regions: [] },

                    { name: "Providence", faction: "Super Earth", sector: "Iptus Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Krakabos", faction: "Super Earth", sector: "Iptus Sector", biome: "Basic Swamp", weather: "Rainstorms", links: [], regions: [] },

                    { name: "Iridica", faction: "Super Earth", sector: "Iptus Sector", biome: "Ethereal Jungle", weather: "None", links: [], regions: [] },

                    { name: "Ratch", faction: "Super Earth", sector: "Iptus Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Valgaard", faction: "Super Earth", sector: "Iptus Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: [], regions: [] },

                    { name: "Primordia", faction: "Super Earth", sector: "Iptus Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: [], regions: [] },

                    { name: "Acamar IV", faction: "Super Earth", sector: "Jin Xi Sector", biome: "Plains", weather: "Rainstorms", links: ["Crimsica", "Turing", "Darius II", "Gacrux", "Pandion-XXIV"], regions: ["Settlement – DEMOCRACY ALWAYS", "City – ERIDANI"] },

                    { name: "Gacrux", faction: "Terminid", sector: "Jin Xi Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Acamar IV", "Fori Prime", "Partion", "Pandion-XXIV"], regions: [] },

                    { name: "Pandion-XXIV", faction: "Terminid", sector: "Jin Xi Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Acamar IV", "Gacrux", "Phact Bay"], regions: [] },

                    { name: "Phact Bay", faction: "Terminid", sector: "Jin Xi Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Gatria", "Pandion-XXIV", "Partion", "Darius II", "Gar Haren"], regions: ["Town – OLD DOVE", "City – BRNO", "MegaCity – NEW EAGLE"] },

                    { name: "Gatria", faction: "Terminid", sector: "Jin Xi Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Trandor", "Gar Haren", "Phact Bay", "Pherkad Secundus"], regions: ["Settlement – ALTONBURG", "City – ERSATZ"] },

                    { name: "Gar Haren", faction: "Terminid", sector: "Jin Xi Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Phact Bay", "Achernar Secundus", "Gatria", "Grand Errant"], regions: [] },

                    { name: "Zegema Paradise", faction: "Super Earth", sector: "Kelvin Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: [], regions: [] },

                    { name: "Fort Justice", faction: "Super Earth", sector: "Kelvin Sector", biome: "Ethereal Jungle", weather: "None", links: [], regions: [] },

                    { name: "New Kiruna", faction: "Super Earth", sector: "Kelvin Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: [], regions: [] },

                    { name: "Igla", faction: "Super Earth", sector: "Kelvin Sector", biome: "Boneyard", weather: "Extreme Cold", links: [], regions: [] },

                    { name: "Emeria", faction: "Super Earth", sector: "Kelvin Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Barabos", "Borea"], regions: ["MegaCity – NEW ASPIRATION CITY"] },

                    { name: "Inari", faction: "Super Earth", sector: "Korpus Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Alta V", "Ursica XI", "Veld"], regions: [] },

                    { name: "Crucible", faction: "Super Earth", sector: "Korpus Sector", biome: "Tundra", weather: "None", links: ["Krakatwo", "Volterra"], regions: ["Settlement – KURRI KURRI", "Town – ANNWN", "MegaCity – AGARTHA", "MegaCity – PROMINENCE"] },

                    { name: "Volterra", faction: "Super Earth", sector: "Korpus Sector", biome: "Plains", weather: "Rainstorms", links: ["Crucible", "Slif", "Caramoor", "Alta V"], regions: ["Town – SCARLET HAVEN", "Town – EDWARD’S GRAVE", "MegaCity – LIGHT-OF-LIBERTY"] },

                    { name: "Caramoor", faction: "Super Earth", sector: "Korpus Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Volterra", "Alta V"], regions: ["City – LEMURIA RISING", "City – PIONEER’S DREAM", "City – BASE CAMP 8"] },

                    { name: "Alta V", faction: "Super Earth", sector: "Korpus Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Volterra", "Slif", "Caramoor", "Inari"], regions: ["Town – PORTE LIBERTÉ", "Settlement – UNDERVATTEN"] },

                    { name: "Enuliale", faction: "Terminid", sector: "L’estrade Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Epsilon Phoencis VI", "Diaspora X"], regions: [] },

                    { name: "Diaspora X", faction: "Terminid", sector: "L’estrade Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Enuliale", "Gemstone Bluffs"], regions: [] },

                    { name: "Epsilon Phoencis VI", faction: "Terminid", sector: "L’estrade Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Enuliale", "Gemstone Bluffs"], regions: [] },

                    { name: "Gemstone Bluffs", faction: "Terminid", sector: "L’estrade Sector", biome: "Plains", weather: "Rainstorms", links: ["Epsilon Phoencis VI", "Diaspora X", "Nabatea Secundus"], regions: [] },

                    { name: "Omicron", faction: "Terminid", sector: "L’estrade Sector", biome: "Hive World", weather: "None", links: ["Oshaune", "Zagon Prime"], regions: [] },

                    { name: "Nabatea Secundus", faction: "Terminid", sector: "L’estrade Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Gemstone Bluffs", "Navi VII"], regions: [] },

                    { name: "Navi VII", faction: "Terminid", sector: "L’estrade Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Nabatea Secundus"], regions: [] },

                    { name: "Choohe", faction: "Automaton", sector: "Lacaille Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Aurora Bay", "Matar Bay", "Chort Bay", "Menkent"], regions: [] },

                    { name: "Chort Bay", faction: "Super Earth", sector: "Lacaille Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Choohe", "Lesath", "Menkent", "Aurora Bay", "Merak"], regions: [] },

                    { name: "Lesath", faction: "Super Earth", sector: "Lacaille Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Vernen Wells", "Menkent", "Gaellivare", "Vog-Sojoth", "Chort Bay"], regions: ["Town – SERENITY SUMMIT", "Town – MORSKIE OKO", "City – CRYSTAL SLOPES", "MegaCity – BUCU’S REST"] },

                    { name: "Penta", faction: "Super Earth", sector: "Lacaille Sector", biome: "Deadlands", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Halies Port", faction: "Super Earth", sector: "Leo Sector", biome: "Boneyard", weather: "Extreme Cold", links: [], regions: [] },

                    { name: "Haka", faction: "Super Earth", sector: "Leo Sector", biome: "Deadlands", weather: "Thick Fog", links: [], regions: [] },

                    { name: "Ras Algethi", faction: "Super Earth", sector: "Leo Sector", biome: "Tundra", weather: "None", links: [], regions: [] },

                    { name: "Propus", faction: "Super Earth", sector: "Leo Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: [], regions: [] },

                    { name: "Barabos", faction: "Super Earth", sector: "Marspira Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Emeria", "Fenmire"], regions: [] },

                    { name: "Fenmire", faction: "Super Earth", sector: "Marspira Sector", biome: "Plains", weather: "Rainstorms", links: ["Barabos", "Mastia", "Curia"], regions: ["Town – BRAWFERMLAND", "MegaCity – NEW ABERDEEN", "MegaCity – SAORSA GLEN"] },

                    { name: "Curia", faction: "Super Earth", sector: "Marspira Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Fenmire", "Tarsh", "Borea", "Aesir Pass"], regions: [] },

                    { name: "Tarsh", faction: "Super Earth", sector: "Marspira Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Vernen Wells", "Mastia", "Curia"], regions: ["Settlement – FORTITUDE", "Settlement – FREEDOM’S TORCH", "Settlement – FEARLESS HOLLOW"] },

                    { name: "Mastia", faction: "Super Earth", sector: "Marspira Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Fenmire", "Shallus", "Tarsh", "Shelt", "Gaellivare"], regions: [] },

                    { name: "Emorath", faction: "Super Earth", sector: "Meridian Sector", biome: "Ethereal Jungle", weather: "None", links: ["Ilduna Prime", "East Iridium Trading Bay", "Liberty Ridge", "Viridia Prime"], regions: ["Town – FARMHANDSTOWN", "Settlement – FORT BOUNTY", "MegaCity – FUTURIA"] },

                    { name: "Ilduna Prime", faction: "Super Earth", sector: "Meridian Sector", biome: "Tundra", weather: "None", links: ["Baldrick Prime", "Emorath"], regions: [] },

                    { name: "Liberty Ridge", faction: "Super Earth", sector: "Meridian Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Canopus", "Emorath", "Baldrick Prime"], regions: ["Settlement – VANQUISHMENT", "City – FREECREST"] },

                    { name: "Baldrick Prime", faction: "Super Earth", sector: "Meridian Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Liberty Ridge", "Obari", "Ilduna Prime"], regions: [] },

                    { name: "Hellmire", faction: "Super Earth", sector: "Mirin Sector", biome: "Scorched Moor", weather: "Intense Heat; Fire Tornados", links: ["Erata Prime", "Fenrir III", "Estanu", "Oshaune"], regions: [] },

                    { name: "Oshaune", faction: "Super Earth", sector: "Mirin Sector", biome: "Hive World", weather: "None", links: ["Hellmire", "Fori Prime", "Omicron"], regions: [] },

                    { name: "Nivel 43", faction: "Terminid", sector: "Mirin Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Erson Sands", "Erata Prime", "Zagon Prime", "Esker"], regions: [] },

                    { name: "Zagon Prime", faction: "Terminid", sector: "Mirin Sector", biome: "Hive World", weather: "None", links: ["Omicron", "Nivel 43"], regions: [] },

                    { name: "Myrium", faction: "Super Earth", sector: "Morgon Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Seyshel Beach", "Kerth Secundus", "Eukoria", "Valmox"], regions: ["City – PILOT’S BERTH", "Town – PLETHORA", "City – ANTBOOT"] },

                    { name: "Eukoria", faction: "Super Earth", sector: "Morgon Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Fort Sanctuary", "Myrium", "Regnus"], regions: [] },

                    { name: "Regnus", faction: "Illuminate", sector: "Morgon Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Eukoria", "Mog"], regions: ["Town – PEOPLE’S HAND", "Town – TOPSOIL", "City – HUMAN WILL"] },

                    { name: "Mog", faction: "Illuminate", sector: "Morgon Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Regnus", "Valmox", "Adhara"], regions: [] },

                    { name: "Duma Tyr", faction: "Super Earth", sector: "Nanos Sector", biome: "Tundra", weather: "None", links: ["Julheim", "Oslo Station", "Borea", "Bekvam III"], regions: [] },

                    { name: "Bekvam III", faction: "Super Earth", sector: "Nanos Sector", biome: "Ethereal Jungle", weather: "None", links: ["Duma Tyr", "Charon Prime", "Marfark", "Julheim"], regions: ["Town – CONVENIENCE", "City – FIREFLY MEADOWS"] },

                    { name: "Julheim", faction: "Super Earth", sector: "Nanos Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Bekvam III", "Charbal-VII", "Dolph", "Duma Tyr"], regions: ["MegaCity – FROSTOWN"] },

                    { name: "Dolph", faction: "Super Earth", sector: "Nanos Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Julheim", "Pöpli IX", "Caph", "Oslo Station"], regions: [] },

                    { name: "Karlia", faction: "Super Earth", sector: "Omega Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Alathfar XI", "Hydrobius", "Keid"], regions: ["City – ADNAN"] },

                    { name: "Hydrobius", faction: "Illuminate", sector: "Omega Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: ["Senge 23", "Setia", "Alaraph", "Heze Bay", "Karlia"], regions: ["City – GENERATORSVILLE"] },

                    { name: "Setia", faction: "Illuminate", sector: "Omega Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Senge 23", "Hydrobius", "Shete"], regions: [] },

                    { name: "Senge 23", faction: "Illuminate", sector: "Omega Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Seasse", "Hydrobius", "Setia"], regions: ["Town – EXALT", "Settlement – EAGLESTAR ETERNAL"] },

                    { name: "Seasse", faction: "Illuminate", sector: "Omega Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Rogue 5", "Rirga Bay", "Senge 23"], regions: [] },

                    { name: "Veld", faction: "Super Earth", sector: "Orion Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: ["Slif", "Inari", "Turing"], regions: ["Town – CLE ELUM REDIVIVA", "MegaCity – LAELIA"] },

                    { name: "Angel’s Venture", faction: "Super Earth", sector: "Orion Sector", biome: "Tundra", weather: "None", links: [], regions: [] },

                    { name: "Heeth", faction: "Super Earth", sector: "Orion Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Cirrus", "Fenrir III", "Erata Prime"], regions: [] },

                    { name: "Terrek", faction: "Super Earth", sector: "Orion Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Azterra", "Cirrus", "Bore Rock"], regions: [] },

                    { name: "Azterra", faction: "Super Earth", sector: "Orion Sector", biome: "Rocky Canyons", weather: "Thick Fog", links: ["Sulfura", "Cirrus", "Terrek"], regions: [] },

                    { name: "Fort Union", faction: "Super Earth", sector: "Orion Sector", biome: "Plains", weather: "Rainstorms", links: ["Nublaria I", "Cirrus"], regions: ["Town – OTARU’S PLEDGE", "City – XIAMEN ANEW", "Town – MUNITION CITY", "MegaCity – NEW HOPE CITY"] },

                    { name: "Cirrus", faction: "Super Earth", sector: "Orion Sector", biome: "Deadlands", weather: "Thick Fog", links: ["Fort Union", "Terrek", "Heeth", "Azterra"], regions: [] },

                    { name: "Leng Secundus", faction: "Super Earth", sector: "Quintus Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Klaka 5", "Kraz", "Stout"], regions: [] },

                    { name: "Stout", faction: "Super Earth", sector: "Quintus Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Leng Secundus", "Stor Tha Prime"], regions: [] },

                    { name: "Spherion", faction: "Super Earth", sector: "Quintus Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Kneth Port", "Stor Tha Prime", "Sirius"], regions: [] },

                    { name: "Stor Tha Prime", faction: "Super Earth", sector: "Quintus Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Termadon", "Spherion", "Stout"], regions: [] },

                    { name: "Termadon", faction: "Super Earth", sector: "Quintus Sector", biome: "Plains", weather: "Rainstorms", links: ["Stor Tha Prime"], regions: [] },

                    { name: "Parsh", faction: "Illuminate", sector: "Rictus Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Effluvia", "Reaf", "Kerth Secundus", "Genesis Prime"], regions: ["City – PORUGU", "MegaCity – PADOSAN"] },

                    { name: "Kerth Secundus", faction: "Illuminate", sector: "Rictus Sector", biome: "Tundra", weather: "None", links: ["Parsh", "Seyshel Beach", "Myrium", "Grafmere"], regions: ["Town – SCHOLAR’S MOOR", "Town – BLESTRAIL", "MegaCity – HILDOARA CENTRAL"] },

                    { name: "Grafmere", faction: "Illuminate", sector: "Rictus Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Kerth Secundus", "Oasis", "Iro"], regions: ["City – GRAFSART", "Settlement – GRAFSWALLIT", "MegaCity – GRAFSEAD"] },

                    { name: "Genesis Prime", faction: "Illuminate", sector: "Rictus Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: ["Parsh", "Oasis", "Outpost 32", "Alaraph"], regions: ["Town – MALLSTRIP NODES", "City – BIRTH"] },

                    { name: "Oasis", faction: "Illuminate", sector: "Rictus Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Genesis Prime", "Grafmere", "Alamak VII", "Alaraph"], regions: ["City – RESPITE"] },

                    { name: "Iro", faction: "Illuminate", sector: "Rictus Sector", biome: "Haunted Swamp", weather: "Thick Fog", links: ["Grafmere", "Valmox", "New Stockholm"], regions: [] },

                    { name: "Valmox", faction: "Illuminate", sector: "Rictus Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Myrium", "Mog", "Iro", "Afoyay Bay"], regions: ["Settlement – REBELSGRAVE", "City – REFORMED-BY-TRUTH", "City – OBEDIENCE"] },

                    { name: "Rirga Bay", faction: "Illuminate", sector: "Rigel Sector", biome: "Acidic Badlands", weather: "Acid Storms", links: ["Heze Bay", "Hort", "Seasse"], regions: ["Town – BLIGHTSMURK"] },

                    { name: "Hort", faction: "Illuminate", sector: "Rigel Sector", biome: "Plains", weather: "Rainstorms", links: ["Herthon Secundus", "Rirga Bay", "Hesoe Prime", "RD-4"], regions: ["City – ON-EARSAHOU", "City – CLOCKSTOP", "City – MAGNITUDE"] },

                    { name: "Hesoe Prime", faction: "Illuminate", sector: "Rigel Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Hort", "RD-4"], regions: [] },

                    { name: "RD-4", faction: "Illuminate", sector: "Rigel Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Hesoe Prime", "Hort", "Rogue 5"], regions: [] },

                    { name: "Rogue 5", faction: "Illuminate", sector: "Rigel Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["RD-4", "Seasse"], regions: [] },

                    { name: "Gunvald", faction: "Super Earth", sector: "Sagan Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Borea", "Oslo Station"], regions: [] },

                    { name: "Oslo Station", faction: "Super Earth", sector: "Sagan Sector", biome: "Boneyard", weather: "Extreme Cold", links: ["Dolph", "Gunvald", "Duma Tyr"], regions: [] },

                    { name: "Borea", faction: "Super Earth", sector: "Sagan Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Emeria", "Curia", "Duma Tyr", "Gunvald"], regions: [] },

                    { name: "Irulta", faction: "Illuminate", sector: "Saleria Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Diluvia", "Reaf", "Elysian Meadows"], regions: ["Settlement – RECON HEIGHTS", "Town – SILO A", "City – VOTER’S FALLOW"] },

                    { name: "Reaf", faction: "Illuminate", sector: "Saleria Sector", biome: "Plains", weather: "Rainstorms", links: ["Solghast", "Parsh", "Irulta", "Outpost 32"], regions: [] },

                    { name: "Outpost 32", faction: "Super Earth", sector: "Saleria Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Reaf", "Genesis Prime", "Calypso"], regions: [] },

                    { name: "Calypso", faction: "Super Earth", sector: "Saleria Sector", biome: "Rocky Canyons", weather: "Tremors", links: ["Outpost 32", "Elysian Meadows", "Alderidge Cove", "Andar"], regions: [] },

                    { name: "Durgen", faction: "Super Earth", sector: "Severin Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Malevelon Creek", "Ubanea"], regions: [] },

                    { name: "Tibit", faction: "Super Earth", sector: "Severin Sector", biome: "Ethereal Jungle", weather: "None", links: ["Ubanea"], regions: [] },

                    { name: "Malevelon Creek", faction: "Super Earth", sector: "Severin Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: ["Maia", "Mantes", "Durgen", "Draupnir"], regions: ["Settlement – LIFEBLOOD", "Settlement – REQUIEM", "Town – DIVER’S REST"] },

                    { name: "Ubanea", faction: "Super Earth", sector: "Severin Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Tibit", "Durgen", "Draupnir"], regions: ["Town – FREEDOM ETERNAL", "City – NUOVA ROMA"] },

                    { name: "Maia", faction: "Super Earth", sector: "Severin Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Malevelon Creek", "Vandalon IV"], regions: [] },

                    { name: "Mars", faction: "Not in play", sector: "Sol Sector", biome: "sandy_tutorial", weather: "None", links: [], regions: [] },

                    { name: "Super Earth", faction: "Super Earth", sector: "Sol Sector", biome: "Metropolis", weather: "Rainstorms", links: [], regions: ["MegaCity – EAGLEOPOLIS", "ADMINISTRATIVE CENTER 02", "REMEMBRANCE", "YORK SUPREME", "PORT MERCY", "PROSPERITY CITY", "EQUALITY-ON-SEA"] },

                    { name: "Trandor", faction: "Terminid", sector: "Sten Sector", biome: "Tundra", weather: "None", links: ["Gatria", "Peacock"], regions: ["City – NYA SKELLEFTEA", "Settlement – ÖDESHÖGRE", "City – GOTHENBURG III"] },

                    { name: "Azur Secundus", faction: "Terminid", sector: "Sten Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: ["Overgoe Prime"], regions: [] },

                    { name: "Overgoe Prime", faction: "Terminid", sector: "Sten Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Azur Secundus", "Partion"], regions: [] },

                    { name: "Partion", faction: "Terminid", sector: "Sten Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Peacock", "Gacrux", "Overgoe Prime", "Phact Bay"], regions: [] },

                    { name: "Peacock", faction: "Terminid", sector: "Sten Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: ["Trandor", "Partion"], regions: ["Settlement – QUASAR", "Town – SYZYGY"] },

                    { name: "Shallus", faction: "Super Earth", sector: "Talus Sector", biome: "Ethereal Jungle", weather: "None", links: ["Mastia", "Shelt"], regions: [] },

                    { name: "Shelt", faction: "Super Earth", sector: "Talus Sector", biome: "Tundra", weather: "None", links: ["Mastia", "Shallus", "Imber"], regions: [] },

                    { name: "Imber", faction: "Super Earth", sector: "Talus Sector", biome: "Scorched Moor", weather: "Fire Tornados; Intense Heat", links: ["Shelt", "Gaellivare", "Claorell"], regions: [] },

                    { name: "Gaellivare", faction: "Super Earth", sector: "Talus Sector", biome: "Volcanic Jungle", weather: "Rainstorms; Volcanic Activity", links: ["Mastia", "Lesath", "Imber"], regions: ["Settlement – VÁHTJER", "MegaCity – MALMBERGET"] },

                    { name: "Claorell", faction: "Super Earth", sector: "Tanis Sector", biome: "Moon", weather: "Extreme Cold; Meteor Storms", links: ["Vog-Sojoth", "Imber", "Clasa"], regions: ["City – MAJOSYRI", "City – QUASAR", "MegaCity – ZENITH"] },

                    { name: "Vog-Sojoth", faction: "Super Earth", sector: "Tanis Sector", biome: "Icy Glaciers", weather: "Blizzards; Extreme Cold", links: ["Lesath", "Claorell", "Clasa"], regions: ["Town – HAERSTVIK"] },

                    { name: "Clasa", faction: "Super Earth", sector: "Tanis Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Vog-Sojoth", "Claorell", "Yed Prior", "Zefia", "Demiurg"], regions: ["Settlement – SYCAMORE GARDENS", "Town – KODIAK FALLS", "City – VOTING DISTRICT F-012357"] },

                    { name: "Demiurg", faction: "Super Earth", sector: "Tanis Sector", biome: "Tundra", weather: "None", links: ["Clasa"], regions: [] },

                    { name: "Zefia", faction: "Super Earth", sector: "Tanis Sector", biome: "Ethereal Jungle", weather: "None", links: ["Mintoria", "Yed Prior", "Clasa"], regions: [] },

                    { name: "Yed Prior", faction: "Super Earth", sector: "Tanis Sector", biome: "Ionic Crimson", weather: "Ion Storms", links: ["Blistica", "Clasa", "Zefia"], regions: [] },

                    { name: "East Iridium Trading Bay", faction: "Super Earth", sector: "Tarragon Sector", biome: "Basic Swamp", weather: "Rainstorms", links: ["Emorath", "Elysian Meadows", "Brink-2"], regions: [] },

                    { name: "Osupsam", faction: "Super Earth", sector: "Tarragon Sector", biome: "Desert Dunes", weather: "Intense Heat; Sandstorms", links: ["Canopus", "Klaka 5", "Brink-2"], regions: [] },

                    { name: "Canopus", faction: "Super Earth", sector: "Tarragon Sector", biome: "Desert Cliffs", weather: "Intense Heat; Tremors", links: ["Bunda Secundus", "Liberty Ridge", "Osupsam"], regions: [] },

                    { name: "Bunda Secundus", faction: "Super Earth", sector: "Tarragon Sector", biome: "Tundra", weather: "None", links: ["Kraz", "Canopus"], regions: [] },

                    { name: "Brink-2", faction: "Super Earth", sector: "Tarragon Sector", biome: "Ionic Jungle", weather: "Ion Storms", links: ["East Iridium Trading Bay", "Osupsam", "Kneth Port"], regions: [] },
                ]
            }
        };

        /***********************
         * App State
         ***********************/
        const STORAGE_KEY = "hd2_chaos_roulette_v1";

        const state = {
            items: null,
            cards: [],

            // current spin
            current: {
                seed: null,
                seedBase: null,
                mode: null,
                faction: null,
                loadout: null,      // {primary, sidearm, throwable, stratagems[4], fingerprint}
                locked: false,
                planet: null,       // {name, sector, biome, weather}
                planetBiome: null,
                planetLocked: false,

                specialActive: false,
                rerollsLeft: 0,
                spinning: false
            }
        };

        function loadState() {
            const raw = localStorage.getItem(STORAGE_KEY);

            // Always start from defaults
            state.items = deepClone(DEFAULTS.items);
            state.cards = [];

            // Normalize default faction strings immediately
            sanitizeFactionData();

            if (!raw) return;

            try {
                const parsed = JSON.parse(raw);

                if (parsed.items) {
                    // Merge saved edits INTO defaults instead of replacing them
                    Object.keys(parsed.items).forEach(key => {
                        if (Array.isArray(parsed.items[key])) {
                            // Merge arrays by name (for planets, stratagems, etc)
                            const saved = parsed.items[key];
                            const base = state.items[key];

                            saved.forEach(savedItem => {
                                const match = base.find(b => b.name === savedItem.name);
                                if (match) {
                                    Object.assign(match, savedItem);
                                } else {
                                    base.push(savedItem);
                                }
                            });
                        } else {
                            state.items[key] = parsed.items[key];
                        }
                    });
                }

                state.cards = parsed.cards || [];

            } catch {
                state.items = deepClone(DEFAULTS.items);
                state.cards = [];
            }

            // Normalize any mismatched faction strings from defaults/imports/saves
            sanitizeFactionData();

        }

        function saveState() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify({
                items: state.items,
                cards: state.cards
            }));
            updateHeaderPills();
        }

        /***********************
         * Seed naming
         ***********************/
        function makeSeedBase() {
            const a = DEFAULTS.seedWordsA[randInt(DEFAULTS.seedWordsA.length)];
            const b = DEFAULTS.seedWordsB[randInt(DEFAULTS.seedWordsB.length)];
            return `${a} ${b}`;
        }
        function ensureUniqueSeed(seedBase) {
            // If seed exists already, append #2, #3...
            const existing = new Set(state.cards.map(c => c.seed));
            if (!existing.has(seedBase)) return seedBase;
            let i = 2;
            while (existing.has(`${seedBase}#${i}`)) i++;
            return `${seedBase}#${i}`;
        }

        /***********************
         * Random selection (equal chance)
         ***********************/
        function enabledNames(list) {

            // If nothing enabled, automatically fallback to ALL items
            const enabled = list.filter(x => x.enabled);

            if (enabled.length === 0) {
                return list.map(x => x.name);
            }

            return enabled.map(x => x.name);
        }
        function pickOne(list) {
            const arr = enabledNames(list);
            if (!arr.length) return "—";
            return arr[randInt(arr.length)];
        }
        function pickManyUnique(list, count) {
            // Unique picks (no duplicates within one spin). If the pool is smaller than
            // count, we fill the remaining slots with "—" rather than repeating items.
            const arr = enabledNames(list);
            if (!arr.length) return Array(count).fill("—");

            // Fisher–Yates shuffle for uniform randomness.
            const shuffled = arr.slice();
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = randInt(i + 1);
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            const out = shuffled.slice(0, Math.min(count, shuffled.length));
            while (out.length < count) out.push("—");
            return out;
        }

        function fingerprintLoadout(l) {
            // fingerprint excludes planet (planet is rolled separately)
            // includes: mode + faction + weapons + strat list
            const parts = [
                l.mode, l.faction,
                l.primary, l.sidearm, l.throwable,
                ...l.stratagems
            ];
            return parts.map(normalizeText).join("|");
        }

        function hasDuplicateFingerprint(fp) {
            return state.cards.some(c => c.fingerprint === fp);
        }

        /***********************
         * Spin logic
         ***********************/
        function rollMode() {
            // equal chance: Blitz (12) or Standard (40)
            return Math.random() < 0.5 ? "Blitz (12)" : "Standard (40)";
        }
        function rollFaction() {
            const roll = Math.random();

            if (roll < 0.33) return "Terminids";
            if (roll < 0.66) return "Automatons";
            return "Illuminate";
        }

        function rollLoadout(seed) {
            const mode = rollMode();
            const faction = rollFaction();
            const primary = pickOne(state.items.primaries);
            const sidearm = pickOne(state.items.sidearms);
            const throwable = pickOne(state.items.throwables);
            const stratagems = pickManyUnique(state.items.stratagems, 4);

            const temp = { mode, faction, primary, sidearm, throwable, stratagems };
            const fp = fingerprintLoadout(temp);
            return {
                seed,
                mode,
                faction,
                primary,
                sidearm,
                throwable,
                stratagems,
                fingerprint: fp
            };
        }

        function rollPlanetForFaction(faction) {
            const spinF = String(faction || "").toLowerCase().trim();

            const pool = (state.items.planets || []).filter(p => {
                const enabled = (typeof p.enabled === "boolean") ? p.enabled : true;
                if (!enabled) return false;

                const f = String(p.faction || "").toLowerCase().trim();

                if (f === "super earth") return false;
                if (f === "not in play") return false;

                // singular / plural match
                if (f === spinF) return true;
                if (f === spinF.replace(/s$/, "")) return true;
                if ((f + "s") === spinF) return true;

                return false;
            });

            if (!pool.length) return null;

            const p = pool[randInt(pool.length)];
            return {
                name: p.name,
                sector: p.sector || "—",
                biome: p.biome || "—",
                weather: p.weather || "—"
            };
        }

        /***********************
         * Reel animation
         ***********************/

        let reelToken = 0;

        function sampleEnabledText(list) {
            const enabled = list.filter(x => x.enabled);
            if (!enabled.length) return "—";
            return enabled[randInt(enabled.length)].name;
        }

        async function spinReel(el, sampleFn, finalText, baseMs, slowFactor, onFinal) {
            const myToken = reelToken;
            const start = performance.now();
            const total = baseMs;

            let delay = 35;
            const maxDelay = 220 * slowFactor;

            while (true) {
                if (myToken !== reelToken) return;
                const t = performance.now() - start;
                if (t >= total) break;

                el.textContent = sampleFn();
                playTone("tick");

                const p = clamp(t / total, 0, 1);
                const eased = p * p; // ease-out
                delay = 35 + (maxDelay - 35) * eased;

                await new Promise(res => setTimeout(res, delay));
            }

            el.textContent = finalText ?? "—";
            el.style.transform = "scale(1.15)";
            el.style.transition = "transform 0.15s ease";
            playTone("final");

            setTimeout(() => {
                el.style.transform = "scale(1)";
            }, 150);

            if (typeof onFinal === "function") onFinal(finalText);
            await new Promise(res => setTimeout(res, 120));
        }

        async function spinReelsForLoadout(loadout) {
            reelToken++;
            const tokenAtStart = reelToken;



            const els = {
                primary: $("#slotPrimary"),
                sidearm: $("#slotSidearm"),
                throwable: $("#slotThrowable"),
                s1: $("#slotStrat1"),
                s2: $("#slotStrat2"),
                s3: $("#slotStrat3"),
                s4: $("#slotStrat4"),
            };

            Object.values(els).forEach(e => { if (e) e.textContent = "…" });

            const sequence = [
                [els.primary, () => sampleEnabledText(state.items.primaries), loadout.primary, 900, 1.0],
                [els.sidearm, () => sampleEnabledText(state.items.sidearms), loadout.sidearm, 900, 1.0],
                [els.throwable, () => sampleEnabledText(state.items.throwables), loadout.throwable, 950, 1.15],

                [els.s1, () => sampleEnabledText(state.items.stratagems), loadout.stratagems?.[0], 1100, 1.35],
                [els.s2, () => sampleEnabledText(state.items.stratagems), loadout.stratagems?.[1], 1250, 1.45],
                [els.s3, () => sampleEnabledText(state.items.stratagems), loadout.stratagems?.[2], 1400, 1.60],
                [els.s4, () => sampleEnabledText(state.items.stratagems), loadout.stratagems?.[3], 1600, 1.80],
            ];
            for (const entry of sequence) {
                const [el, sampler, finalValue, dur, slow, cb] = entry;
                if (tokenAtStart !== reelToken) return;
                if (!el) continue;
                await spinReel(el, sampler, finalValue, dur, slow, cb);
            }


        }

        /***********************
         * Ranking system (0-100 scale)
         ***********************/
        function computeRawScore(card) {
            const kills = Number(card.stats?.kills ?? 0);
            const deaths = Number(card.stats?.deaths ?? 0);
            const stims = Number(card.stats?.stims ?? 0);
            const stratUses = Number(card.stats?.stratUses ?? 0);

            // Less punishing so most runs don't collapse to 0
            let raw =
                (kills * 1.0) -
                (deaths * 10) -
                (stims * 1) +
                (stratUses * 1.0);

            if (!isFinite(raw)) raw = 0;
            raw = Math.max(0, raw);
            return raw;
        }

        /***********************
         * Pentagon / Radar chart helpers (per-card SVG)
         ***********************/
        function normPos(v, maxV) {
            v = Number(v || 0);
            maxV = Number(maxV || 0);
            if (!isFinite(v) || v < 0) v = 0;
            if (!isFinite(maxV) || maxV <= 0) return 0;
            return clamp(v / maxV, 0, 1);
        }

        // Lower is better: returns 0..1 where 1 = best (lowest)
        function normInverse(v, minV, maxV) {
            v = Number(v || 0);
            minV = Number(minV || 0);
            maxV = Number(maxV || 0);
            if (!isFinite(v) || v < 0) v = 0;
            if (!isFinite(minV) || minV < 0) minV = 0;
            if (!isFinite(maxV) || maxV < 0) maxV = 0;
            if (maxV === minV) return 1; // everyone tied, pretend "maxed"
            return clamp((maxV - v) / (maxV - minV), 0, 1);
        }

        function getRadarMaxes(cards) {
            const out = {
                maxKills: 0,
                maxAccuracy: 0,
                maxDistanceKm: 0,
                maxStratUses: 0,
                minDeathsPlusStims: null,
                maxDeathsPlusStims: 0
            };

            for (const c of (cards || [])) {
                const s = c.stats || {};
                out.maxKills = Math.max(out.maxKills, Number(s.kills || 0));
                out.maxAccuracy = Math.max(out.maxAccuracy, Number(s.accuracy || 0));
                out.maxDistanceKm = Math.max(out.maxDistanceKm, Number(s.distanceKm || 0));
                out.maxStratUses = Math.max(out.maxStratUses, Number(s.stratUses || 0));

                const combo = Number(s.deaths || 0) + Number(s.stims || 0);
                out.maxDeathsPlusStims = Math.max(out.maxDeathsPlusStims, combo);
                if (out.minDeathsPlusStims === null) out.minDeathsPlusStims = combo;
                out.minDeathsPlusStims = Math.min(out.minDeathsPlusStims, combo);
            }

            if (out.minDeathsPlusStims === null) out.minDeathsPlusStims = 0;
            return out;
        }


        function getTierRadarColor(card) {
            const tier = (card && card.tier) || "";
            if (tier === "gold") return { fill: "rgba(255,212,0,.22)", stroke: "#ffd400" };
            if (tier === "silver") return { fill: "rgba(200,210,220,.25)", stroke: "#c8d2dc" };
            if (tier === "bronze") return { fill: "rgba(230,170,90,.25)", stroke: "#e6aa5a" };
            if (tier === "darkbronze") return { fill: "rgba(150,95,40,.28)", stroke: "#965f28" };
            // Rainbow: use the shared SVG gradient so it matches the rainbow rim.
            if (tier === "rainbow") return { fill: "rgba(255,255,255,.18)", stroke: "url(#rainbowStroke)" };
            return { fill: "rgba(255,212,0,.18)", stroke: "#ffd400" };
        }

        function buildRadarSVG(card, maxes) {
            const s = card.stats || {};
            const combo = Number(s.deaths || 0) + Number(s.stims || 0);

            // Axis order matches your screenshot-style labels:
            // Power, Agility, Endurance, Mobility, Utility
            const vals = [
                normPos(s.kills, maxes.maxKills),
                normPos(s.accuracy, maxes.maxAccuracy),
                normInverse(combo, maxes.minDeathsPlusStims, maxes.maxDeathsPlusStims),
                normPos(s.distanceKm, maxes.maxDistanceKm),
                normPos(s.stratUses, maxes.maxStratUses),
            ];

            const moScale = card.majorOrderDone ? 1.0 : 0.75;

            const size = 160;
            const cx = size / 2;
            const cy = size / 2;
            const rOuter = 62;
            const r = rOuter * moScale;

            const angles = [-90, -18, 54, 126, 198].map(a => a * Math.PI / 180);

            const pt = (radius, a) => ({
                x: cx + radius * Math.cos(a),
                y: cy + radius * Math.sin(a)
            });

            const outerPts = angles.map(a => pt(rOuter, a));
            const valuePts = angles.map((a, i) => pt(r * vals[i], a));

            const fmt = (p) => `${p.x.toFixed(1)},${p.y.toFixed(1)}`;
            const polyOuter = outerPts.map(fmt).join(" ");
            const polyVal = valuePts.map(fmt).join(" ");

            // spokes
            const spokes = angles.map((a) => {
                const p2 = pt(rOuter, a);
                return `<line x1="${cx}" y1="${cy}" x2="${p2.x.toFixed(1)}" y2="${p2.y.toFixed(1)}" />`;
            }).join("");

            // grid rings (3 rings)
            const ring = (k) => {
                const rr = rOuter * k;
                const pts = angles.map(a => pt(rr, a)).map(fmt).join(" ");
                return `<polygon points="${pts}" />`;
            };

            const penaltyNote = card.majorOrderDone ? "" : " (MO -25% size)";
            const col = getTierRadarColor(card);

            return `
                  <div class="radarWrap">
                    <svg viewBox="0 0 ${size} ${size}" width="${size}" height="${size}" aria-label="Performance pentagon${penaltyNote}">
                      <g class="radarGrid">
                        ${ring(0.33)}
                        ${ring(0.66)}
                        <polygon points="${polyOuter}" />
                        ${spokes}
                      </g>

                      <polygon class="radarValue" points="${polyVal}" fill="${col.fill}" stroke="${col.stroke}" stroke-width="2" />
                      <circle class="radarDot" cx="${cx}" cy="${cy}" r="2.2" />
                    </svg>
                  </div>
                `;
        }



        /* ===== COMPARE RADAR HELPERS (GLOBAL) ===== */
        function percentDiff(a, b) {
            if (!b) return 0;
            return ((a - b) / b) * 100;
        }


        function buildCompareRadar(cardA, cardB) {
            if (!cardA || !cardB) return;

            const wrapA = document.querySelector("#cmpRadarA");
            const wrapB = document.querySelector("#cmpRadarB");
            const overlay = document.querySelector("#cmpRadarOverlay");
            const insight = document.querySelector("#cmpInsight");
            const btn = document.querySelector("#btnOverlayRadar");

            cmpRadarReadyA = false;
            cmpRadarReadyB = false;
            if (btn) btn.disabled = true;

            if (!wrapA || !wrapB) return;

            const maxes = getRadarMaxes(state.cards || []);

            const tierMap = (typeof buildTierMap === "function") ? buildTierMap() : null;
            const tA = tierMap ? (tierMap.get(cardA.id) || "") : ((cardA && cardA.tier) || "");
            const tB = tierMap ? (tierMap.get(cardB.id) || "") : ((cardB && cardB.tier) || "");

            if (cardA) cardA.tier = tA || cardA.tier || "";
            if (cardB) cardB.tier = tB || cardB.tier || "";

            const titleStyleA = (tA && typeof tierColor === "function") ? ` style="color:${tierColor(tA)}"` : "";
            const titleStyleB = (tB && typeof tierColor === "function") ? ` style="color:${tierColor(tB)}"` : "";

            window.__cmpCtx = {
                idA: cardA.id,
                idB: cardB.id,
                maxes: maxes || null
            };

            const safeMaxes = maxes || { maxKills: 1, maxAccuracy: 1, maxDistanceKm: 1, maxStratUses: 1, minDeathsPlusStims: 0, maxDeathsPlusStims: 1 };
            const cardClassA = `card${tA ? ` tier-${tA}` : ""}`.trim();
            const cardClassB = `card${tB ? ` tier-${tB}` : ""}`.trim();

            wrapA.innerHTML = `
            <div class="${cardClassA}">
                <div class="cmpTitle"${titleStyleA}>${escapeHtml(cardA.seed || "—")}</div>
                ${buildRadarSVG(cardA, safeMaxes)}
            </div>`;

            wrapB.innerHTML = `
            <div class="${cardClassB}">
                <div class="cmpTitle"${titleStyleB}>${escapeHtml(cardB.seed || "—")}</div>
                ${buildRadarSVG(cardB, safeMaxes)}
            </div>`;

            if (overlay) {
                overlay.innerHTML = '<div class="tiny muted">Click <strong>STACK RADARS</strong> to view overlap + highlighted advantages.</div>';
            }
            if (insight) insight.textContent = "";

            requestAnimationFrame(() => {
                cmpRadarReadyA = true;
                cmpRadarReadyB = true;
                tryEnableOverlay();
            });
        }

        function getCompareVals(card, maxes) {
            const s = card?.stats || {};
            const combo = Number(s.deaths || 0) + Number(s.stims || 0);
            const moScale = card?.majorOrderDone ? 1 : 0.75;
            return [
                normPos(s.kills, maxes.maxKills) * moScale,
                normPos(s.accuracy, maxes.maxAccuracy) * moScale,
                normInverse(combo, maxes.minDeathsPlusStims, maxes.maxDeathsPlusStims) * moScale,
                normPos(s.distanceKm, maxes.maxDistanceKm) * moScale,
                normPos(s.stratUses, maxes.maxStratUses) * moScale,
            ].map(v => clamp(v, 0, 1));
        }

        function buildOverlayRadar() {
            const overlay = document.querySelector("#cmpRadarOverlay");
            const insight = document.querySelector("#cmpInsight");
            if (!overlay) return;

            const ctx = window.__cmpCtx || {};
            const idA = ctx.idA || (document.querySelector("#cmpA")?.value || "");
            const idB = ctx.idB || (document.querySelector("#cmpB")?.value || "");
            const cardA = (state.cards || []).find(c => c.id === idA);
            const cardB = (state.cards || []).find(c => c.id === idB);
            const maxes = ctx.maxes || getRadarMaxes(state.cards || []);

            if (!cardA || !cardB || !maxes) {
                overlay.innerHTML = "";
                if (insight) insight.textContent = "Overlay needs two valid cards.";
                return;
            }

            const size = 240, cx = 120, cy = 120, rOuter = 86;
            const axes = [
                { label: "Power", metric: "Kills" },
                { label: "Agility", metric: "Accuracy" },
                { label: "Endurance", metric: "Deaths + Stims" },
                { label: "Mobility", metric: "Distance" },
                { label: "Utility", metric: "Strat uses" },
            ];
            const angles = axes.map((_, i) => (-Math.PI / 2) + (i * (Math.PI * 2 / axes.length)));
            const pt = (r, a) => ({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
            const fmt = (p) => `${p.x.toFixed(1)},${p.y.toFixed(1)}`;

            const valsA = getCompareVals(cardA, maxes);
            const valsB = getCompareVals(cardB, maxes);

            const ptsOuter = angles.map(a => pt(rOuter, a));
            const ptsA = angles.map((a, i) => pt(rOuter * valsA[i], a));
            const ptsB = angles.map((a, i) => pt(rOuter * valsB[i], a));

            const ring = (k) => {
                const rr = rOuter * k;
                const pts = angles.map(a => pt(rr, a)).map(fmt).join(" ");
                return `<polygon points="${pts}" />`;
            };
            const spokes = angles.map(a => {
                const p2 = pt(rOuter, a);
                return `<line x1="${cx}" y1="${cy}" x2="${p2.x.toFixed(1)}" y2="${p2.y.toFixed(1)}" />`;
            }).join("");

            const polyA = ptsA.map(fmt).join(" ");
            const polyB = ptsB.map(fmt).join(" ");

            const colA = getTierRadarColor(cardA);
            const colB = getTierRadarColor(cardB);

            const highlights = [];
            const insightLines = [];
            for (let i = 0; i < axes.length; i++) {
                const a = valsA[i], b = valsB[i];
                if (Math.abs(a - b) < 0.01) continue;

                const winner = a > b ? "A" : "B";
                const high = Math.max(a, b);
                const low = Math.min(a, b);
                const pct = low <= 0 ? 100 : ((high - low) / low) * 100;
                const pctText = `${Math.max(1, pct).toFixed(1)}%`;

                const ang = angles[i];
                const da = 0.14;
                const p1 = pt(rOuter * high, ang - da);
                const p2 = pt(rOuter * high, ang + da);
                const p3 = pt(rOuter * low, ang + da);
                const p4 = pt(rOuter * low, ang - da);
                const winnerSeed = winner === "A" ? (cardA.seed || "Card A") : (cardB.seed || "Card B");
                const loserSeed = winner === "A" ? (cardB.seed || "Card B") : (cardA.seed || "Card A");
                const winnerColor = winner === "A" ? colA.stroke : colB.stroke;
                const label = axes[i].label.toUpperCase();
                const tip = `${winnerSeed} is ${pctText} better on ${label} than ${loserSeed}`;

                highlights.push(`<polygon points="${fmt(p1)} ${fmt(p2)} ${fmt(p3)} ${fmt(p4)}" fill="${winnerColor}" fill-opacity="0.26" stroke="${winnerColor}" stroke-width="1.2"><title>${escapeHtml(tip)}</title></polygon>`);
                insightLines.push(`<span style="color:${winnerColor};font-weight:700;">${escapeHtml(label)}</span>: ${escapeHtml(tip)}`);
            }

            overlay.innerHTML = `
            <svg width="240" height="240" viewBox="0 0 240 240" aria-label="Stacked radar comparison" role="img">
                <g class="radarGrid">
                    ${ring(0.33)}
                    ${ring(0.66)}
                    <polygon points="${ptsOuter.map(fmt).join(" ")}" />
                    ${spokes}
                </g>
                <polygon points="${polyB}" fill="${colB.fill}" stroke="${colB.stroke}" stroke-width="2" opacity="0.8"><title>${escapeHtml(cardB.seed || "Card B")}</title></polygon>
                <polygon points="${polyA}" fill="${colA.fill}" stroke="${colA.stroke}" stroke-width="2" opacity="0.8"><title>${escapeHtml(cardA.seed || "Card A")}</title></polygon>
                ${highlights.join("")}
                <circle class="radarDot" cx="${cx}" cy="${cy}" r="2.2" />
            </svg>`;

            if (insight) {
                insight.innerHTML = insightLines.length
                    ? insightLines.join("<br>")
                    : "Both cards are nearly identical on the stacked radar.";
            }
        }


        /***********************
                 * Tiering (based on rank position)
                 * Target distribution:
                 *  3 rainbow
                 *  5 gold   (places 4-8)
                 *  7 silver (places 9-15)
                 * 10 light bronze (places 16-25)
                 * rest dark bronze/brown (26+)
                 ***********************/
        function tierForPlace(place) {
            if (place <= 3) return "rainbow";
            if (place <= 8) return "gold";
            if (place <= 15) return "silver";
            if (place <= 25) return "bronze";       // light bronze
            return "darkbronze";                   // or "brown" if you want another tier later
        }

        function buildTierMap() {
            // MUST mirror rank ordering: grade desc (tie-breaker: newest first so stable-ish)
            const ordered = state.cards
                .slice()
                .sort((a, b) => {
                    const g = Number(b.grade || 0) - Number(a.grade || 0);
                    if (g !== 0) return g;
                    return (b.createdAt || "").localeCompare(a.createdAt || "");
                });

            const map = new Map(); // id -> tier string
            ordered.forEach((c, idx) => {
                const place = idx + 1;
                map.set(c.id, tierForPlace(place));
            });
            return map;
        }
        function recalcGrades() {
            // Backward-compat: older cards may have stats at top-level.
            for (const c of state.cards) {
                if (!c.stats || typeof c.stats !== "object") c.stats = {};
                const s = c.stats;

                // migrate legacy flat fields if present
                if (s.kills == null && c.kills != null) s.kills = Number(c.kills || 0);
                if (s.accuracy == null && c.accuracy != null) s.accuracy = Number(c.accuracy || 0);
                if (s.deaths == null && c.deaths != null) s.deaths = Number(c.deaths || 0);
                if (s.stims == null && c.stims != null) s.stims = Number(c.stims || 0);
                if (s.distanceKm == null && c.distanceKm != null) s.distanceKm = Number(c.distanceKm || 0);
                if (s.stratUses == null && c.stratUses != null) s.stratUses = Number(c.stratUses || 0);

                // ensure numeric defaults
                s.kills = Number(s.kills || 0);
                s.accuracy = Number(s.accuracy || 0);
                s.deaths = Number(s.deaths || 0);
                s.stims = Number(s.stims || 0);
                s.distanceKm = Number(s.distanceKm || 0);
                s.stratUses = Number(s.stratUses || 0);
            }

            const raws = state.cards.map(c => computeRawScore(c));
            const maxRaw = Math.max(0, ...raws);
            state.cards.forEach((c, i) => {
                const raw = raws[i] ?? 0;
                c.scoreRaw = raw;
                c.grade = (maxRaw <= 0) ? 0 : Math.round((raw / maxRaw) * 100);
            });
        }

        /***********************
         * UI Rendering
         ***********************/
        function updateHeaderPills() {
            $("#pillSaved").textContent = String(state.cards.length);
            $("#spinSavedCount").textContent = String(state.cards.length);

            const c = state.current;

            // MODE: show after LOCK
            $("#pillMode").textContent = c.locked ? (c.mode || "—") : "—";

            // FACTION: show only after ROLL PLANET
            const pillFactionText = $("#pillFaction");
            const pillFactionWrap = pillFactionText.parentElement;

            pillFactionWrap.classList.remove(
                "faction-terminids",
                "faction-automatons",
                "faction-illuminate"
            );

            if (c.planetLocked) {
                pillFactionText.textContent = c.faction || "—";
                pillFactionWrap.classList.add(getFactionClass(c.faction));
            } else {
                pillFactionText.textContent = "—";
            }

            // SEED: always show
            $("#pillSeed").textContent = c.seed || "—";
        }
        function getFactionClass(f) {
            if (!f) return "";
            const n = String(f).toLowerCase();
            if (n.includes("terminid")) return "faction-terminids";
            if (n.includes("automaton")) return "faction-automatons";
            if (n.includes("illuminate")) return "faction-illuminate";
            if (n.includes("super earth") || n.replace(/\s+/g, "").includes("superearth")) return "faction-superearth";
            return "";
        }
        function renderSpin() {
            const c = state.current;

            $("#spinSeed").textContent = c.seed || "—";

            // MODE colors
            const modeEl = $("#spinMode");
            modeEl.classList.remove("mode-standard", "mode-blitz");

            if (!c.locked) {
                modeEl.textContent = "—";
            } else if (c.mode === "Standard (40)") {
                modeEl.textContent = c.mode;
                modeEl.classList.add("mode-standard");
            } else if (c.mode === "Blitz (12)") {
                modeEl.textContent = c.mode;
                modeEl.classList.add("mode-blitz");
            } else {
                modeEl.textContent = "—";
            }






            // Planet display (name + info cards)
            $("#dispPlanet").textContent = c.planet ? c.planet.name : "—";

            const cardsWrap = $("#planetInfoCards");
            const tinyLine = $("#dispPlanetTiny");

            if (c.planet) {
                const sector = c.planet.sector || "—";
                const weatherRaw = getPlanetWeatherText(c.planet);
                const tags = splitWeatherTags(weatherRaw);
                const biome = (c.planetBiome || getPlanetBiomeFromPlanet(c.planet)) || "Unknown";

                // show cards
                cardsWrap.style.display = "";
                cardsWrap.innerHTML = `
                        <div class="planetMiniCard">
                          <div class="planetMiniLabel">Faction</div>
                          <div class="planetMiniValue ${c.planetLocked ? getFactionClass(c.faction) : ""}">
                            ${c.planetLocked ? escapeHtml(c.faction || "—") : "—"}
                          </div>
                        </div>

                        <div class="planetMiniCard">
                          <div class="planetMiniLabel">Sector</div>
                          <div class="planetMiniValue">${escapeHtml(sector || "—")}</div>
                        </div>

                        <div class="planetMiniCard">
                          <div class="planetMiniLabel">Biome</div>
                          <div class="planetMiniValue">${escapeHtml(biome)}</div>
                        </div>

                        <div class="planetMiniCard">
                          <div class="planetMiniLabel">Environment</div>
                          <div class="planetTagRow">
                            ${(tags.length ? tags : [weatherRaw || "None"]).map(t => `<span class="planetTag">${envEmoji(t)} ${escapeHtml(t)}</span>`).join("")}
                          </div>
                        </div>
                      `;

                // hide redundant summary line
                if (tinyLine) {
                    tinyLine.style.display = "none";
                    tinyLine.textContent = "";
                }
            } else {
                // hide cards
                cardsWrap.style.display = "none";
                cardsWrap.innerHTML = "";
                if (tinyLine) {
                    tinyLine.style.display = "none";
                    tinyLine.textContent = "";
                }
            }

            // Buttons
            $("#btnLock").disabled = !c.loadout || c.locked || c.spinning;
            $("#btnRollPlanet").disabled = !c.loadout || !c.locked || c.spinning;
            $("#btnUse").disabled = !c.loadout || !c.locked || c.spinning;


            // Special event reroll
            const rerollBtn = $("#btnReroll");
            if (c.specialActive && c.rerollsLeft > 0) {
                rerollBtn.style.display = "";
                rerollBtn.textContent =
                    `SPECIAL EVENT: REROLL (${c.rerollsLeft})`;
            } else {
                rerollBtn.style.display = "none";
            }

            updateHeaderPills();
        }

        function renderResults() {
            recalcGrades();

            const modeFilter = $("#resFilterMode").value;
            const factionFilter = $("#resFilterFaction").value;
            const sort = $("#resSort").value;

            let list = state.cards.slice();

            if (modeFilter) list = list.filter(c => c.mode === modeFilter);
            if (factionFilter) list = list.filter(c => c.faction === factionFilter);

            const sorter = {
                new: (a, b) => (b.createdAt || "").localeCompare(a.createdAt || ""),
                old: (a, b) => (a.createdAt || "").localeCompare(b.createdAt || ""),
                kills_desc: (a, b) => (Number(b.stats.kills || 0) - Number(a.stats.kills || 0)),
                deaths_asc: (a, b) => (Number(a.stats.deaths || 0) - Number(b.stats.deaths || 0)),
                stims_asc: (a, b) => (Number(a.stats.stims || 0) - Number(b.stats.stims || 0)),
                grade_desc: (a, b) => (Number(b.grade || 0) - Number(a.grade || 0))
            }[sort] || ((a, b) => 0);

            list.sort(sorter);
            const tierMap = buildTierMap();

            const grid = $("#resultsGrid");
            grid.innerHTML = "";

            if (!list.length) {
                grid.innerHTML = `<div class="tiny">No cards yet. Go spin something awful and commit to it.</div>`;
                return;
            }

            const radarMaxes = getRadarMaxes(state.cards);

            for (const card of list) {
                const moBadge = card.majorOrderDone ? `<span class="badge good">MO DONE</span>` : `<span class="badge red">MO NO</span>`;
                const pLine = card.planet ? `${card.planet.name} <span class="muted">(${card.planet.sector || "—"})</span>` : `<span class="muted">Planet: not rolled</span>`;

                const planetWeatherText = card.planet ? getPlanetWeatherText(card.planet) : "None";
                const planetWeatherTags = splitWeatherTags(planetWeatherText);
                const cardBiome = card.planet ? (card.planetBiome || getPlanetBiomeFromPlanet(card.planet) || "—") : "—";

                const tier = tierMap.get(card.id) || "";

                const el = document.createElement("div");

                el.className = "card" + (tier ? ` tier-${tier}` : "");

                el.innerHTML = `
                      <div class="cardTop">
                        <div>
                          <div class="cardTitle">${escapeHtml(card.seed)}</div>
                          <div class="cardMeta">
                            ${escapeHtml(card.mode)} •
<span class="${getFactionClass(card.faction)}">${escapeHtml(card.faction)}</span> •
                            <span class="muted">${escapeHtml(new Date(card.createdAt).toLocaleString())}</span>
                          </div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:6px; align-items:flex-end;">
                          <span class="badge yellow">Grade ${Number(card.grade || 0)}</span>
                          ${moBadge}
                        </div>
                      </div>

                      <div class="cardLine"><strong>Primary:</strong> ${escapeHtml(card.primary)}</div>
                      <div class="cardLine"><strong>Sidearm:</strong> ${escapeHtml(card.sidearm)}</div>
                      <div class="cardLine"><strong>Throwable:</strong> ${escapeHtml(card.throwable)}</div>
                      <div class="cardLine"><strong>Strats:</strong> ${escapeHtml((card.stratagems || []).join(" • "))}</div>
                      <div class="cardLine"><strong>Planet:</strong> ${pLine}</div>

                      ${card.planet ? `
                        <div class="planetCardWrap" style="margin-top:10px;">
                          <div class="planetMiniCard">
                            <div class="planetMiniLabel">Sector</div>
                            <div class="planetMiniValue">${escapeHtml(card.planet.sector || "—")}</div>
                          </div>

                          <div class="planetMiniCard">
                            <div class="planetMiniLabel">Biome</div>
                            <div class="planetMiniValue">${escapeHtml(cardBiome)}</div>
                          </div>

                          <div class="planetMiniCard">
                            <div class="planetMiniLabel">Environment</div>
                            <div class="planetMiniValue">${escapeHtml(planetWeatherTags.length ? planetWeatherTags.slice(0, 3).join(" / ") : (planetWeatherText || "None"))}${planetWeatherTags.length > 3 ? ` (+${planetWeatherTags.length - 3})` : ""}</div>
                            <div class="planetTagRow">
                              ${(planetWeatherTags.length ? planetWeatherTags : [planetWeatherText || "None"]).map(t => `<span class="planetTag">${envEmoji(t)} ${escapeHtml(t)}</span>`).join("")}
                            </div>
                          </div>

                          <div class="planetMiniCard">
                            <div class="planetMiniLabel">Faction</div>
                            <div class="planetMiniValue ${getFactionClass(card.faction)}">
                      ${escapeHtml(card.faction || "—")}
</div>
                          </div>
                        </div>
                      ` : ``}

                      <div class="hr"></div>

                      <div class="formGrid3 statsGrid cardInputGrid">
                        <div>
                          <div class="label">Kills</div>
                          <input type="number" min="0" value="${Number(card.stats?.kills || 0)}" data-k="kills" data-id="${card.id}">
                        </div>
                        <div>
                          <div class="label">Accuracy (%)</div>
                          <input type="number" min="0" value="${Number(card.stats?.accuracy || 0)}" data-k="accuracy" data-id="${card.id}">
                        </div>
                        <div>
                          <div class="label">Deaths</div>
                          <input type="number" min="0" value="${Number(card.stats?.deaths || 0)}" data-k="deaths" data-id="${card.id}">
                        </div>
                        <div>
                          <div class="label">Stims</div>
                          <input type="number" min="0" value="${Number(card.stats?.stims || 0)}" data-k="stims" data-id="${card.id}">
                        </div>
                        <div>
                          <div class="label">Distance (km)</div>
                          <input type="number" min="0" step="0.1" value="${Number(card.stats?.distanceKm || 0)}" data-k="distanceKm" data-id="${card.id}">
                        </div>
                        <div>
                          <div class="label">Strat uses</div>
                          <input type="number" min="0" value="${Number(card.stats?.stratUses || 0)}" data-k="stratUses" data-id="${card.id}">
                        </div>
                      </div>

                      <div class="cardMetaGrid">
                        <div>
                          <div class="label">Deaths + Stims</div>
                          <div class="tiny"><strong>${Number(card.stats?.deaths || 0) + Number(card.stats?.stims || 0)}</strong> (lower = better endurance)</div>
                        </div>
                        <div>
                          <div class="label">Pentagon</div>
                          ${buildRadarSVG(card, radarMaxes)}
                        </div>
                      </div>

                      <div class="tiny" style="margin-top:8px;">
                        POWER=kills • AGILITY=accuracy • ENDURANCE=deaths+stims (lower) • MOBILITY=km • UTILITY=strat uses${card.majorOrderDone ? "" : " • MO FAIL: -25% size"}
                      </div>

                      <div class="formGrid" style="margin-top:10px;">
                        <div>
                          <div class="label">Major order done</div>
                          <select data-k="majorOrderDone" data-id="${card.id}">
                            <option value="false" ${card.majorOrderDone ? "" : "selected"}>No</option>
                            <option value="true" ${card.majorOrderDone ? "selected" : ""}>Yes</option>
                          </select>
                        </div>
                      </div>

                      <div style="margin-top:10px;">
                        <div class="label">Notes</div>
                        <textarea data-k="notes" data-id="${card.id}" placeholder="Write anything: what sucked, what worked, funny moments...">${escapeHtml(card.notes || "")}</textarea>
                      </div>

                      <div class="miniRow" style="justify-content:space-between; margin-top:10px;">
                        <div class="tiny">Raw: <strong>${Number(card.scoreRaw || 0).toFixed(1)}</strong></div>
                        <div class="miniRow">
                          <button class="btnPrimary" data-act="saveCard" data-id="${card.id}">SAVE</button>
                          <button class="btnGhost" data-act="deleteCard" data-id="${card.id}">DELETE</button>
                        </div>
                      </div>
`;

                grid.appendChild(el);
            }

            // bind inputs
            grid.querySelectorAll("input, textarea, select").forEach(inp => {
                inp.addEventListener("change", onCardFieldChange);
                inp.addEventListener("input", (e) => {
                    // keep it responsive but not too chatty
                    if (e.target.tagName.toLowerCase() === "textarea") onCardFieldChange(e);
                });
            });

            grid.querySelectorAll("button[data-act]").forEach(btn => {
                btn.addEventListener("click", onCardAction);
            });

            refreshCompareOptions();
            renderRank();
        }

        function onCardFieldChange(e) {
            const el = e.target;
            const id = el.getAttribute("data-id");
            const key = el.getAttribute("data-k");
            if (!id || !key) return;

            const card = state.cards.find(c => c.id === id);
            if (!card) return;

            // ensure stats container exists
            if (!card.stats || typeof card.stats !== "object") card.stats = {};

            // numeric stat fields
            const STAT_KEYS = ["kills", "accuracy", "deaths", "stims", "distanceKm", "stratUses"];

            if (key === "majorOrderDone") {
                card.majorOrderDone = (el.value === "true");
            } else if (key === "notes") {
                card.notes = el.value;
            } else if (STAT_KEYS.includes(key)) {
                card.stats[key] = Number(el.value || 0);
            }

            recalcGrades();
            // saveState();
            updateHeaderPills();
            renderRank();
            refreshCompareOptions();
            // keep results view stable, no full redraw per keystroke except textarea input is fine
        }

        function onCardAction(e) {
            const act = e.target.getAttribute("data-act");
            const id = e.target.getAttribute("data-id");
            const card = state.cards.find(c => c.id === id);
            if (!card) return;

            if (act === "deleteCard") {
                if (!confirm("Delete this card?")) return;
                state.cards = state.cards.filter(c => c.id !== id);
                saveState();
                renderResults();
                return;
            }
            if (act === "saveCard") {
                // Sync latest typed values (even if user didn't blur the input yet)
                const cardEl = e.target.closest(".card") || document;
                const fields = cardEl.querySelectorAll(`[data-id="${id}"][data-k]`);
                const STAT_KEYS = ["kills", "accuracy", "deaths", "stims", "distanceKm", "stratUses"];
                fields.forEach(el => {
                    const key = el.getAttribute("data-k");
                    if (!key) return;
                    if (key === "majorOrderDone") {
                        card.majorOrderDone = (String(el.value) === "true");
                    } else if (key === "notes") {
                        card.notes = el.value;
                    } else if (STAT_KEYS.includes(key)) {
                        if (!card.stats) card.stats = {};
                        card.stats[key] = Number(el.value || 0);
                    }
                });

                // Recalculate score + grade and persist
                recalcGrades();
                saveState();
                renderResults();

                // Tiny confirmation so you know it worked
                alert("Saved ✅");
                return;
            }


        }

        /***********************
         * Compare
         ***********************/
        const METRICS = [
            { k: "grade", label: "Grade (0-100)" },
            { k: "kills", label: "Kills (Power)" },
            { k: "accuracy", label: "Accuracy (Agility)" },
            { k: "deathsPlusStims", label: "Deaths + Stims (Endurance, low is good)" },
            { k: "distanceKm", label: "Distance km (Mobility)" },
            { k: "stratUses", label: "Strat uses (Utility)" },
            { k: "raw", label: "Raw score" }
        ];

        function refreshCompareOptions() {
            const a = $("#cmpA"), b = $("#cmpB");
            if (!a || !b) return;

            const prevA = a.value, prevB = b.value;

            const opts = state.cards
                .slice()
                .sort((x, y) => (y.createdAt || "").localeCompare(x.createdAt || ""))
                .map(c => ({ id: c.id, text: `${c.seed} • ${c.mode} • ${c.faction} • Grade ${c.grade || 0}` }));

            const build = (sel) => {
                sel.innerHTML = "";
                const o0 = document.createElement("option");
                o0.value = "";
                o0.textContent = "Select a card...";
                sel.appendChild(o0);
                for (const o of opts) {
                    const opt = document.createElement("option");
                    opt.value = o.id;
                    opt.textContent = o.text;
                    sel.appendChild(opt);
                }
            };
            build(a); build(b);

            a.value = prevA || "";
            b.value = prevB || "";

            // Auto-pick sensible defaults so COMPARE isn't blank on entry
            if (!a.value && opts.length) a.value = opts[0].id;
            if (!b.value && opts.length) b.value = opts[Math.min(1, opts.length - 1)].id;

            // Avoid same-card vs same-card unless user explicitly chose it
            if (a.value && b.value && a.value === b.value && opts.length > 1) {
                b.value = opts.find(o => o.id !== a.value)?.id || b.value;
            }
            // Metric dropdowns for graph (optional; some builds remove the graph UI)
            const gx = $("#gX"), gy = $("#gY");
            if (gx && gy) {
                gx.innerHTML = ""; gy.innerHTML = "";
                for (const m of METRICS) {
                    const ox = document.createElement("option");
                    ox.value = m.k;
                    ox.textContent = m.label;
                    gx.appendChild(ox);

                    const oy = document.createElement("option");
                    oy.value = m.k;
                    oy.textContent = m.label;
                    gy.appendChild(oy);
                }
                gx.value = gx.value || "kills";
                gy.value = gy.value || "deaths";
            }

            renderCompare();
            if (typeof updateCompareRadar === "function") updateCompareRadar();
        }

        function metricValue(card, k) {
            if (k === "grade") return Number(card.grade || 0);
            if (k === "raw") return Number(card.scoreRaw || 0);

            const s = card.stats || {};
            if (k === "deathsPlusStims") return Number(s.deaths || 0) + Number(s.stims || 0);

            return Number(s[k] || 0);
        }

        function renderCompare() {
            recalcGrades();

            const idA = $("#cmpA").value;
            const idB = $("#cmpB").value;
            const ca = state.cards.find(c => c.id === idA);
            const cb = state.cards.find(c => c.id === idB);

            const table = $("#cmpTable");
            table.innerHTML = "";

            const rows = [
                { name: "Grade (0-100)", k: "grade", better: "high" },
                { name: "Kills", k: "kills", better: "high" },
                { name: "Deaths", k: "deaths", better: "low" },
                { name: "Stims", k: "stims", better: "low" },
                { name: "Raw score", k: "raw", better: "high" },
            ];

            const header = `
                            <tr>
                              <th>Metric</th>
                              <th>${ca ? escapeHtml(ca.title || ca.seed) : "Card A"}</th>
                              <th>${cb ? escapeHtml(cb.title || cb.seed) : "Card B"}</th>
                            </tr>
                          `;
            table.insertAdjacentHTML("beforeend", header);

            for (const r of rows) {
                const va = ca ? metricValue(ca, r.k) : null;
                const vb = cb ? metricValue(cb, r.k) : null;

                let clsA = "", clsB = "";
                if (ca && cb) {
                    if (r.better === "high") {
                        if (va > vb) { clsA = "good"; clsB = "bad"; }
                        else if (vb > va) { clsB = "good"; clsA = "bad"; }
                    } else {
                        if (va < vb) { clsA = "good"; clsB = "bad"; }
                        else if (vb < va) { clsB = "good"; clsA = "bad"; }
                    }
                }

                table.insertAdjacentHTML("beforeend", `
                              <tr>
                                <td class="muted">${escapeHtml(r.name)}</td>
                                <td class="${clsA}">${va ?? "—"}</td>
                                <td class="${clsB}">${vb ?? "—"}</td>
                              </tr>
                            `);
            }
        }

        // --- Graph hover state (global) ---
        let graphPoints = []; // {x,y,r,card,tier,color}
        let graphHoverWired = false;

        function tierColor(tier) {
            // matches your results/rank vibe
            if (tier === "gold") return "#ffd400";
            if (tier === "silver") return "#c8d2dc";
            if (tier === "bronze") return "#e6aa5a";
            if (tier === "darkbronze") return "#965f28";
            if (tier === "brown") return "#78502d";
            if (tier === "rainbow") return "#ffffff"; // base, rainbow drawn as segmented ring
            return "rgba(255,212,0,.85)";
        }

        function drawRainbowRing(ctx, x, y, rOuter, rInner) {
            const colors = ["#ff3b3b", "#ffd400", "#2ecc71", "#3b82f6", "#a855f7", "#ff3b3b"];
            const seg = (Math.PI * 2) / (colors.length - 1);

            // outer ring segments
            for (let i = 0; i < colors.length - 1; i++) {
                ctx.beginPath();
                ctx.strokeStyle = colors[i];
                ctx.lineWidth = Math.max(2, rOuter - rInner);
                ctx.arc(x, y, (rOuter + rInner) / 2, i * seg, (i + 1) * seg);
                ctx.stroke();
            }

            // inner fill to keep it readable
            ctx.beginPath();
            ctx.fillStyle = "rgba(0,0,0,.65)";
            ctx.arc(x, y, rInner - 1, 0, Math.PI * 2);
            ctx.fill();
        }

        function showGraphTip(card, tier, clientX, clientY) {
            const tip = document.getElementById("graphTip");
            if (!tip) return;

            const title = card.title || card.seed || "Untitled";
            const planet = card.planet?.name ? `${card.planet.name}${card.planet.sector ? ` (${card.planet.sector})` : ""}` : "—";
            const weather = card.planet?.weather || "—";

            tip.innerHTML = `
                        <div class="tTitle">
                          ${escapeHtml(title)}
                          <span class="tBadge">${escapeHtml(tier || "—")}</span>
                        </div>
                        <div class="tLine"><span class="tMuted">Mode:</span> ${escapeHtml(card.mode || "—")} • <span class="tMuted">Faction:</span> ${escapeHtml(card.faction || "—")}</div>
                        <div class="tLine"><span class="tMuted">Grade:</span> <strong>${Number(card.grade || 0)}</strong> • <span class="tMuted">Raw:</span> ${Number(card.scoreRaw || 0).toFixed(1)}</div>


                        <div class="tLine"><span class="tMuted">Primary:</span> ${escapeHtml(card.primary || "—")}</div>
                        <div class="tLine"><span class="tMuted">Sidearm:</span> ${escapeHtml(card.sidearm || "—")}</div>
                        <div class="tLine"><span class="tMuted">Throwable:</span> ${escapeHtml(card.throwable || "—")}</div>
                        <div class="tLine"><span class="tMuted">Strats:</span> ${escapeHtml((card.stratagems || []).join(" • ") || "—")}</div>

                        <div class="tLine"><span class="tMuted">Planet:</span> ${escapeHtml(planet)}</div>
                        <div class="tLine"><span class="tMuted">Weather:</span> ${escapeHtml(weather)}</div>
                      `;

            // position near mouse, clamp inside viewport
            const pad = 12;
            const vw = window.innerWidth;
            const vh = window.innerHeight;

            tip.style.display = "block";
            const rect = tip.getBoundingClientRect();

            let x = clientX + 14;
            let y = clientY + 14;

            if (x + rect.width + pad > vw) x = clientX - rect.width - 14;
            if (y + rect.height + pad > vh) y = clientY - rect.height - 14;

            tip.style.left = `${Math.max(pad, x)}px`;
            tip.style.top = `${Math.max(pad, y)}px`;
        }

        function hideGraphTip() {
            const tip = document.getElementById("graphTip");
            if (!tip) return;
            tip.style.display = "none";
        }

        function wireGraphHover() {
            if (graphHoverWired) return;
            graphHoverWired = true;

            const cvs = document.getElementById("graphCanvas");
            if (!cvs) return;

            cvs.addEventListener("mousemove", (e) => {
                if (!graphPoints.length) {
                    hideGraphTip();
                    return;
                }

                const rect = cvs.getBoundingClientRect();
                const scaleX = cvs.width / rect.width;
                const scaleY = cvs.height / rect.height;

                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                // find nearest within radius
                let best = null;
                let bestD2 = Infinity;

                for (const p of graphPoints) {
                    const dx = mx - p.x;
                    const dy = my - p.y;
                    const d2 = dx * dx + dy * dy;
                    const hitR = (p.r + 4);
                    if (d2 <= hitR * hitR && d2 < bestD2) {
                        best = p;
                        bestD2 = d2;
                    }
                }

                if (best) {
                    showGraphTip(best.card, best.tier, e.clientX, e.clientY);
                    cvs.style.cursor = "pointer";
                } else {
                    hideGraphTip();
                    cvs.style.cursor = "default";
                }
            });

            cvs.addEventListener("mouseleave", () => {
                hideGraphTip();
                cvs.style.cursor = "default";
            });

            // if user scrolls while hovering, tooltip can look goofy; just hide it
            window.addEventListener("scroll", hideGraphTip, { passive: true });
        }

        function drawGraph() {
            // Graph UI is optional. If it is not present, do nothing.
            if (!$("#graphCanvas") || !$("#gX") || !$("#gY") || !$("#gFilterFaction") || !$("#gFilterMode") || !$("#gFilterHas")) return;
            recalcGrades();
            wireGraphHover();

            const xK = $("#gX").value;
            const yK = $("#gY").value;
            const fFaction = $("#gFilterFaction").value;
            const fMode = $("#gFilterMode").value;
            const contains = normalizeText($("#gFilterHas").value);

            let list = state.cards.slice();
            if (fFaction) list = list.filter(c => c.faction === fFaction);
            if (fMode) list = list.filter(c => c.mode === fMode);

            if (contains) {
                list = list.filter(c => {
                    const hay = normalizeText([
                        c.seed, c.title, c.primary, c.sidearm, c.throwable,
                        (c.stratagems || []).join(" "),
                        c.planet?.name, c.planet?.sector, (c.planet?.weatherText || c.planet?.weather)
                    ].join(" "));
                    return hay.includes(contains);
                });
            }

            const cvs = $("#graphCanvas");
            const ctx = cvs.getContext("2d");

            // reset hover points
            graphPoints = [];

            // Clear
            ctx.clearRect(0, 0, cvs.width, cvs.height);

            const pad = 50;
            const w = cvs.width, h = cvs.height;
            const plotW = w - pad * 2;
            const plotH = h - pad * 2;

            // axes
            ctx.strokeStyle = "rgba(255,255,255,.18)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad, pad);
            ctx.lineTo(pad, h - pad);
            ctx.lineTo(w - pad, h - pad);
            ctx.stroke();

            // labels
            ctx.fillStyle = "rgba(255,255,255,.75)";
            ctx.font = "14px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
            ctx.fillText(`${metricLabel(xK)} →`, pad, pad - 14);
            ctx.fillText(`↑ ${metricLabel(yK)}`, pad, pad - 30);

            if (!list.length) {
                ctx.fillStyle = "rgba(255,255,255,.5)";
                ctx.font = "16px " + getComputedStyle(document.documentElement).getPropertyValue("--sans");
                ctx.fillText("No data for filters.", pad, pad + 10);
                hideGraphTip();
                return;
            }

            const tierMap = buildTierMap();

            const xs = list.map(c => metricValue(c, xK));
            const ys = list.map(c => metricValue(c, yK));
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);

            const scaleX = (v) => {
                if (maxX === minX) return pad + plotW / 2;
                return pad + ((v - minX) / (maxX - minX)) * plotW;
            };
            const scaleY = (v) => {
                if (maxY === minY) return pad + plotH / 2;
                return (h - pad) - ((v - minY) / (maxY - minY)) * plotH;
            };

            // faint grid lines
            ctx.strokeStyle = "rgba(255,255,255,.06)";
            ctx.lineWidth = 1;
            const gridN = 5;
            for (let i = 1; i < gridN; i++) {
                const gx = pad + (plotW / gridN) * i;
                const gy = pad + (plotH / gridN) * i;
                ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, h - pad); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(pad, gy); ctx.lineTo(w - pad, gy); ctx.stroke();
            }

            // points
            for (let i = 0; i < list.length; i++) {
                const card = list[i];
                const x = scaleX(xs[i]);
                const y = scaleY(ys[i]);

                const tier = tierMap.get(card.id) || "";
                const manual = (card.rimColor && String(card.rimColor).trim()) ? String(card.rimColor).trim() : "";
                const baseColor = manual || tierColor(tier);

                const r = 5;

                // draw dot with tier styling
                if (!manual && tier === "rainbow") {
                    drawRainbowRing(ctx, x, y, 8, 5);
                    // center dot
                    ctx.beginPath();
                    ctx.fillStyle = "rgba(255,255,255,.92)";
                    ctx.arc(x, y, 3.2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.fillStyle = baseColor;
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();

                    // subtle outline for readability
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(0,0,0,.55)";
                    ctx.lineWidth = 2;
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.stroke();
                }

                graphPoints.push({ x, y, r: (manual || tier !== "rainbow") ? r : 8, card, tier, color: baseColor });
            }

            // bounding labels
            ctx.fillStyle = "rgba(255,255,255,.55)";
            ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
            ctx.fillText(`minX ${minX} | maxX ${maxX}`, pad, h - 16);
            ctx.fillText(`minY ${minY} | maxY ${maxY}`, w - pad - 220, pad - 16);
        }





        function metricLabel(k) {
            const m = METRICS.find(x => x.k === k);
            return m ? m.label : k;
        }

        /***********************
         * Items editor
         ***********************/
        function renderItemList(containerId, list, onToggle, onDelete) {
            const box = document.getElementById(containerId);
            box.innerHTML = "";

            const wrap = document.createElement("div");
            wrap.style.display = "flex";
            wrap.style.flexDirection = "column";
            wrap.style.gap = "8px";

            list.forEach((it, idx) => {
                const outer = document.createElement("div");
                outer.className = "rankOuter";

                const row = document.createElement("div");
                row.className = "rankRow";
                row.style.justifyContent = "space-between";
                row.style.border = "1px solid rgba(255,255,255,.06)";
                row.style.borderRadius = "12px";
                row.style.padding = "8px 10px";
                row.style.background = "rgba(0,0,0,.18)";

                const left = document.createElement("div");
                left.style.display = "flex";
                left.style.flexDirection = "column";
                left.style.gap = "2px";

                const name = document.createElement("div");
                name.style.fontWeight = "800";
                name.style.fontSize = "12px";
                name.textContent = it.name;

                const meta = document.createElement("div");
                meta.className = "tiny";
                meta.textContent = it.enabled ? "Enabled" : "Disabled";

                left.appendChild(name);
                left.appendChild(meta);

                const right = document.createElement("div");
                right.className = "miniRow";

                const tgl = document.createElement("button");
                tgl.className = it.enabled ? "btnPrimary" : "btnGhost";
                tgl.textContent = it.enabled ? "ENABLED" : "DISABLED";
                tgl.addEventListener("click", () => onToggle(idx));

                const del = document.createElement("button");
                del.className = "btnDanger";
                del.textContent = "DEL";
                del.addEventListener("click", () => onDelete(idx));

                right.appendChild(tgl);
                right.appendChild(del);

                row.appendChild(left);
                row.appendChild(right);
                wrap.appendChild(row);
            });

            box.appendChild(wrap);
        }

        function renderPlanets() {
            const box = $("#listPlanets");
            const list = state.items.planets || [];
            box.innerHTML = "";

            if (!list.length) {
                box.innerHTML = `<div class="tiny">No planets listed. Add some below.</div>`;
                return;
            }

            // Ensure every planet has enabled flag (default true)
            list.forEach(p => {
                if (typeof p.enabled !== "boolean") p.enabled = true;
            });

            const wrap = document.createElement("div");
            wrap.style.display = "flex";
            wrap.style.flexDirection = "column";
            wrap.style.gap = "8px";

            list.forEach((p, idx) => {
                const row = document.createElement("div");
                row.className = "miniRow";
                row.style.justifyContent = "space-between";
                row.style.border = "1px solid rgba(255,255,255,.06)";
                row.style.borderRadius = "12px";
                row.style.padding = "8px 10px";
                row.style.background = "rgba(0,0,0,.18)";
                row.style.opacity = p.enabled ? "1" : "0.55";

                const left = document.createElement("div");
                left.innerHTML = `
                          <div style="font-weight:900; font-size:12px;">${escapeHtml(p.name)}</div>
                          <div class="tiny">
                            ${escapeHtml(p.faction || "—")} • ${escapeHtml(p.sector || "—")} •
                            <span class="muted">${escapeHtml(p.weather || "—")}</span>
                            • <span class="muted">${p.enabled ? "Enabled" : "Disabled"}</span>
                          </div>
                        `;

                const right = document.createElement("div");
                right.className = "miniRow";

                // Toggle only. No delete button. You asked for it. Congrats.
                const tgl = document.createElement("button");
                tgl.className = p.enabled ? "btnPrimary" : "btnGhost";
                tgl.textContent = p.enabled ? "ENABLED" : "DISABLED";
                tgl.addEventListener("click", () => {
                    p.enabled = !p.enabled;
                    saveState();
                    renderPlanets();
                });

                right.appendChild(tgl);
                row.appendChild(left);
                row.appendChild(right);
                wrap.appendChild(row);
            });

            box.appendChild(wrap);
        }

        function renderItems() {
            renderItemList("listPrimaries", state.items.primaries,
                (i) => { state.items.primaries[i].enabled = !state.items.primaries[i].enabled; saveState(); renderItems(); },
                (i) => { state.items.primaries.splice(i, 1); saveState(); renderItems(); }
            );
            renderItemList("listSidearms", state.items.sidearms,
                (i) => { state.items.sidearms[i].enabled = !state.items.sidearms[i].enabled; saveState(); renderItems(); },
                (i) => { state.items.sidearms.splice(i, 1); saveState(); renderItems(); }
            );
            renderItemList("listThrowables", state.items.throwables,
                (i) => { state.items.throwables[i].enabled = !state.items.throwables[i].enabled; saveState(); renderItems(); },
                (i) => { state.items.throwables.splice(i, 1); saveState(); renderItems(); }
            );
            renderItemList("listStrats", state.items.stratagems,
                (i) => { state.items.stratagems[i].enabled = !state.items.stratagems[i].enabled; saveState(); renderItems(); },
                (i) => { state.items.stratagems.splice(i, 1); saveState(); renderItems(); }
            );
            renderPlanets();
        }

        /***********************
         * Rank rendering
         ***********************/
        function renderRank() {
            recalcGrades();

            const list = state.cards.slice().sort((a, b) => {
                const g = Number(b.grade || 0) - Number(a.grade || 0);
                if (g !== 0) return g;
                return (b.createdAt || "").localeCompare(a.createdAt || "");
            });

            const box = $("#rankList");
            box.innerHTML = "";

            if (!list.length) {
                box.innerHTML = `<div class="tiny">No cards to rank yet.</div>`;
                return;
            }

            list.forEach((c, idx) => {
                const place = idx + 1;

                const outer = document.createElement("div");
                outer.className = "rankOuter";

                const row = document.createElement("div");
                row.className = "rankRow";

                const tier = tierForPlace(place);

                if (tier === "rainbow") {
                    outer.classList.add("rim-rainbow");
                } else {
                    row.classList.add(`rim-${tier}`);
                }

                row.innerHTML = `
                          <div>
                            <div style="font-weight:900;">#${place} • ${escapeHtml(c.title || c.seed)}</div>
                            <div class="tiny">${escapeHtml(c.mode)} • ${escapeHtml(c.faction)} • <span class="muted">${escapeHtml(c.primary)}</span></div>
                          </div>
                          <div style="text-align:right;">
                            <div class="badge yellow">Grade ${Number(c.grade || 0)}</div>
                            <div class="tiny">Raw ${Number(c.scoreRaw || 0).toFixed(1)}</div>
                          </div>
                        `;

                outer.appendChild(row);
                box.appendChild(outer);
            });
        }

        /***********************
         * Escape HTML for safe rendering
         ***********************/
        function escapeHtml(s) {
            s = String(s ?? "");
            return s.replace(/[&<>"']/g, m => ({
                "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;"
            }[m]));
        }

        /***********************
         * Event wiring
         ***********************/
        function switchTab(tab) {
            $$(".tabBtn").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
            $("#tab-spin").style.display = (tab === "spin") ? "" : "none";
            $("#tab-results").style.display = (tab === "results") ? "" : "none";
            $("#tab-compare").style.display = (tab === "compare") ? "" : "none";
            $("#tab-items").style.display = (tab === "items") ? "" : "none";
            $("#tab-rank").style.display = (tab === "rank") ? "" : "none";

            if (tab === "results") renderResults();
            if (tab === "compare") {
                refreshCompareOptions();
                // Ensure layout + options are ready before drawing radars (COMPARE tab is hidden until now)
                requestAnimationFrame(() => requestAnimationFrame(() => {
                    if (typeof updateCompareRadar === "function") updateCompareRadar();
                }));
                drawGraph();
            }
            if (tab === "items") renderItems();
            if (tab === "rank") renderRank();
        }


        function doSpin(forceReroll = false) {

            if (!state.current) {
                state.current = {};
            }

            const seedBase = makeSeedBase();
            const seed = ensureUniqueSeed(`Seed: ${seedBase}`);

            const loadout = rollLoadout(seed);

            if (!loadout) {
                alert("LOADOUT FAILED: No enabled items found.");
                console.error("rollLoadout returned null");
                return;
            }

            state.current.seedBase = seedBase;
            state.current.seed = seed;
            state.current.mode = null;
            state.current.faction = null;
            state.current._pendingMode = loadout.mode;
            state.current._pendingFaction = normalizeFactionName(loadout.faction);
            state.current.loadout = loadout;
            state.current.locked = false;

            // planet separate, reset it each spin
            state.current.planet = null;
            state.current.planetLocked = false;
            state.current.planetBiome = null;

            // special event: only if EXACT same fingerprint already exists in saved cards
            if (hasDuplicateFingerprint(loadout.fingerprint)) {
                state.current.specialActive = true;
                state.current.rerollsLeft = 3;
            } else {
                state.current.specialActive = false;
                state.current.rerollsLeft = 0;
            }

            // update top display AFTER reels finish, but we still set data now
            state.current.spinning = true;
            renderSpin();

            spinReelsForLoadout(loadout).then(() => {
                state.current.spinning = false;
                renderSpin();
            });
        }

        function doReroll() {
            if (!state.current.specialActive || state.current.rerollsLeft <= 0) return;
            state.current.rerollsLeft -= 1;

            // keep seed unique even on reroll
            const seedBase = state.current.seedBase || makeSeedBase();
            const seed = ensureUniqueSeed(`Seed:${seedBase}`);

            const loadout = rollLoadout(seed);
            state.current.seed = seed;
            state.current.mode = loadout.mode;
            state.current.faction = normalizeFactionName(loadout.faction);
            state.current.loadout = loadout;
            state.current.locked = false;
            state.current.planet = null;
            state.current.planetLocked = false;
            state.current.planetBiome = null;

            // if reroll produced non-duplicate, disable special mode immediately
            if (!hasDuplicateFingerprint(loadout.fingerprint)) {
                state.current.specialActive = false;
                state.current.rerollsLeft = 0;
            }

            renderSpin();
            spinReelsForLoadout(loadout);
        }

        function doLock() {
            if (!state.current.loadout) return;
            // safety reset in case spinning got stuck
            state.current.spinning = false;

            state.current.mode = state.current._pendingMode;
            state.current.faction = state.current._pendingFaction;

            state.current.locked = true;
            renderSpin();
        }
        function doRollPlanet() {
            if (!state.current.loadout || !state.current.locked) return;
            const p = rollPlanetForFaction(state.current.faction);
            if (!p) {
                alert("No planets available for that faction. Add planets in ITEMS tab.");
                return;
            }
            const pc = deepClone(p);

            // Hook internal planet database → biome is resolved AFTER roll.
            // (Roll returns biome when available, but we also resolve by name for safety.)
            pc.biome = pc.biome || getPlanetBiomeFromPlanet(pc) || "—";

            pc.weatherText = getPlanetWeatherText(pc) || "None";
            state.current.planet = pc;
            state.current.planetBiome = pc.biome; // cached for UI + card persistence
            state.current.planetLocked = true;
            renderSpin();
        }

        function doClearPlanet() {
            // Renamed behavior: "REROLL PLANET" (roll again instead of clearing)
            if (!state.current.loadout || !state.current.locked) return;

            const p = rollPlanetForFaction(state.current.faction);
            if (!p) {
                alert("No planets available for that faction. Add planets in ITEMS tab.");
                return;
            }
            const pc = deepClone(p);

            // Hook internal planet database → biome is resolved AFTER reroll too.
            pc.biome = pc.biome || getPlanetBiomeFromPlanet(pc) || "—";

            pc.weatherText = getPlanetWeatherText(pc) || "None";
            state.current.planet = pc;
            state.current.planetBiome = pc.biome;
            state.current.planetLocked = true;
            renderSpin();
        }

        function doUseThisRun() {
            // create card only if locked
            const c = state.current;
            if (!c.loadout || !c.locked) return;

            const card = {
                id: uid(),
                createdAt: nowISO(),
                seed: c.seed,
                mode: c.mode,
                faction: normalizeFactionName(c.faction),
                primary: c.loadout.primary,
                sidearm: c.loadout.sidearm,
                throwable: c.loadout.throwable,
                stratagems: c.loadout.stratagems.slice(),
                fingerprint: c.loadout.fingerprint,

                planet: c.planet ? deepClone(c.planet) : null,

                planetBiome: c.planetBiome || null,

                // user-entered mission stats are filled on each individual card.
                stats: {
                    kills: 0,
                    accuracy: 0,
                    deaths: 0,
                    stims: 0,
                    distanceKm: 0,
                    stratUses: 0,
                },

                majorOrderDone: false,
                notes: "",

                scoreRaw: 0,
                grade: 0
            };
            // persist biome at confirmation time
            try { card.planetBiome = (card.planetBiome || getPlanetBiomeFromPlanet(card.planet)); } catch (e) { }

            state.cards.unshift(card);
            recalcGrades();
            saveState();

            // After using, keep the current loadout visible but prevent accidental re-use without spinning again
            switchTab("results");
        }


        function exportJSON() {
            const payload = JSON.stringify({ items: state.items, cards: state.cards }, null, 2);
            const filename = `hd2_roulette_backup_${new Date().toISOString().slice(0, 10)}.json`;
            download(filename, payload);
        }

        function importJSONFile(file) {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const parsed = JSON.parse(String(reader.result || ""));
                    if (!parsed || typeof parsed !== "object") throw new Error("bad");
                    if (parsed.items) state.items = parsed.items;
                    if (parsed.cards) state.cards = parsed.cards;
                    recalcGrades();
                    saveState();
                    renderItems();
                    renderResults();
                    renderRank();
                    refreshCompareOptions();
                    drawGraph();
                    alert("Import complete.");
                } catch {
                    alert("Import failed. That file is not valid roulette JSON.");
                }
            };
            reader.readAsText(file);
        }

        /***********************
         * DOM events
         ***********************/
        function wire() {
            $$(".tabBtn").forEach(btn => {
                btn.addEventListener("click", () => switchTab(btn.dataset.tab));
            });

            $("#btnSpin").addEventListener("click", () => doSpin());
            $("#btnReroll").addEventListener("click", () => doReroll());
            $("#btnLock").addEventListener("click", () => doLock());
            $("#btnUse").addEventListener("click", () => doUseThisRun());

            $("#resFilterMode").addEventListener("change", renderResults);
            $("#resFilterFaction").addEventListener("change", renderResults);
            $("#resSort").addEventListener("change", renderResults);

            $("#cmpA").addEventListener("change", renderCompare);
            $("#cmpB").addEventListener("change", renderCompare);
            $("#btnOverlayRadar").addEventListener("click", () => {
                if (!cmpRadarReadyA || !cmpRadarReadyB) return;
                buildOverlayRadar();
            });
            $("#cmpSortMetric").addEventListener("change", refreshCompareOptions);
            $("#cmpSortDir").addEventListener("change", refreshCompareOptions);
            $("#cmpSearch").addEventListener("input", refreshCompareOptions);



            $("#btnExport").addEventListener("click", exportJSON);
            $("#btnImport").addEventListener("click", () => $("#importFile").click());
            $("#importFile").addEventListener("change", (e) => {
                const f = e.target.files && e.target.files[0];
                if (f) importJSONFile(f);
                e.target.value = "";
            });

            $("#btnClearAll").addEventListener("click", () => {
                if (!confirm("This will delete ALL saved cards and item edits. Continue?")) return;
                localStorage.removeItem(STORAGE_KEY);
                loadState();
                saveState();
                renderResults();
                updateSavedCount();
                state.current = { seed: null, seedBase: null, mode: null, faction: null, loadout: null, locked: false, planet: null, planetLocked: false, specialActive: false, rerollsLeft: 0 };
                renderSpin();
                renderResults();
                refreshCompareOptions();
                renderRank();
                renderItems();
            });

            $("#btnRecalcRanks").addEventListener("click", () => {
                recalcGrades();
                renderRank();
                alert("Ranks recalculated.");
            });

            $("#btnResetDefaults").addEventListener("click", () => {
                if (!confirm("Reset item lists to defaults? Your custom edits will be overwritten.")) return;
                state.items = deepClone(DEFAULTS.items);
                saveState();
                renderItems();
                alert("Defaults restored.");
            });

            $("#btnSaveItems").addEventListener("click", () => {
                saveState();
                alert("Items saved.");
            });

            // Add item buttons
            $("#btnAddPrimary").addEventListener("click", () => {
                const v = $("#addPrimary").value.trim();
                if (!v) return;
                state.items.primaries.push({ name: v, enabled: true });
                $("#addPrimary").value = "";
                saveState(); renderItems();
            });
            $("#btnAddSidearm").addEventListener("click", () => {
                const v = $("#addSidearm").value.trim();
                if (!v) return;
                state.items.sidearms.push({ name: v, enabled: true });
                $("#addSidearm").value = "";
                saveState(); renderItems();
            });
            $("#btnAddThrowable").addEventListener("click", () => {
                const v = $("#addThrowable").value.trim();
                if (!v) return;
                state.items.throwables.push({ name: v, enabled: true });
                $("#addThrowable").value = "";
                saveState(); renderItems();
            });

            $("#btnAddStrat").addEventListener("click", () => {
                const v = $("#addStrat").value.trim();
                if (!v) return;
                state.items.stratagems.push({ name: v, enabled: true });
                $("#addStrat").value = "";
                saveState(); renderItems();
            });

            $("#btnAddPlanet").addEventListener("click", () => {
                const name = $("#pName").value.trim();
                const faction = $("#pFaction").value;
                const sector = $("#pSector").value.trim();
                const weather = $("#pWeather").value.trim();

                if (!name) return alert("Planet name required.");

                state.items.planets = state.items.planets || [];
                state.items.planets.push({
                    name,
                    faction,
                    sector: sector || "—",
                    weather: weather || "—",
                    enabled: true
                });

                $("#pName").value = "";
                $("#pSector").value = "";
                $("#pWeather").value = "";

                saveState(); renderPlanets();
            });

            // Optional: let the planet button reroll instead of “roll once”
            // You already wrote doClearPlanet() as “reroll planet” behavior.
            // If you want the same button to reroll after the first roll, use this:
            $("#btnRollPlanet").addEventListener("click", () => {
                // If not rolled yet -> first roll, else reroll
                if (!state.current.planetLocked) doRollPlanet();
                else doClearPlanet();
            });

        } // end wire()
        wireOnce();

        /***********************
         * Compare: Sort + Search (you had UI, but it did nothing)
         ***********************/
        function refreshCompareOptions() {
            const a = $("#cmpA"), b = $("#cmpB");
            if (!a || !b) return;

            recalcGrades();

            // Apply search + sort to the dropdown list shown in compare selectors
            const sortMetric = $("#cmpSortMetric")?.value || "grade";
            const sortDir = $("#cmpSortDir")?.value || "desc";
            const q = normalizeText($("#cmpSearch")?.value || "");

            let list = state.cards.slice();

            if (q) {
                list = list.filter(c => {
                    const hay = normalizeText([
                        c.seed, c.title, c.mode, c.faction,
                        c.primary, c.sidearm, c.throwable,
                        (c.stratagems || []).join(" "),
                        c.planet?.name, c.planet?.sector, (c.planet?.weatherText || c.planet?.weather)
                    ].join(" "));
                    return hay.includes(q);
                });
            }

            const dir = (sortDir === "asc") ? 1 : -1;
            list.sort((x, y) => {
                const vx = (sortMetric === "grade")
                    ? Number(x.grade || 0)
                    : Number(x.stats?.[sortMetric] || 0);

                const vy = (sortMetric === "grade")
                    ? Number(y.grade || 0)
                    : Number(y.stats?.[sortMetric] || 0);

                const d = (vx - vy) * dir;
                if (d !== 0) return d;

                // tie-breaker: newest first
                return (y.createdAt || "").localeCompare(x.createdAt || "");
            });

            const prevA = a.value, prevB = b.value;

            const opts = list.map(c => ({
                id: c.id,
                text: `${c.seed} • ${c.mode} • ${c.faction} • Grade ${c.grade || 0}`
            }));

            const build = (sel) => {
                sel.innerHTML = "";
                const o0 = document.createElement("option");
                o0.value = "";
                o0.textContent = "Select a card...";
                sel.appendChild(o0);

                for (const o of opts) {
                    const opt = document.createElement("option");
                    opt.value = o.id;
                    opt.textContent = o.text;
                    sel.appendChild(opt);
                }
            };

            build(a); build(b);
            a.value = prevA || "";
            b.value = prevB || "";

            // Metric dropdowns for graph
            const gx = $("#gX"), gy = $("#gY");
            if (gx && gy) {
                gx.innerHTML = ""; gy.innerHTML = "";
                for (const m of METRICS) {
                    const ox = document.createElement("option");
                    ox.value = m.k;
                    ox.textContent = m.label;
                    gx.appendChild(ox);

                    const oy = document.createElement("option");
                    oy.value = m.k;
                    oy.textContent = m.label;
                    gy.appendChild(oy);
                }
                gx.value = gx.value || "kills";
                gy.value = gy.value || "deaths";
            }

            renderCompare();
        }

        /***********************
         * Fix: reroll seed formatting bug
         ***********************/
        // In doReroll(), change:
        // const seed = ensureUniqueSeed(`Seed:${seedBase}`);
        // to:
        // const seed = ensureUniqueSeed(`Seed: ${seedBase}`);

        /***********************
         * Boot
         ***********************/
        loadState();
        saveState();      // ensures pills show correct saved count
        wireOnce();
        initApp();
        switchTab("spin");
        renderSpin();
        setTimeout(() => { renderResults(); }, 0);

        /* ===== AUTO COMPARE RADAR WIRING ===== */
        function updateCompareRadar() {
            const selA = document.querySelector("#cmpA");
            const selB = document.querySelector("#cmpB");
            const boxA = document.getElementById("cmpRadarA");
            const boxB = document.getElementById("cmpRadarB");
            const boxO = document.getElementById("cmpRadarOverlay");
            const insight = document.getElementById("cmpInsight");

            const idA = selA ? selA.value : "";
            const idB = selB ? selB.value : "";


            // Compare overlay must never run before both radars exist (render order lock)
            cmpRadarReadyA = false;
            cmpRadarReadyB = false;
            const btnOverlay = document.querySelector("#btnOverlayRadar");
            if (btnOverlay) btnOverlay.disabled = true;

            // If selections aren't ready yet, keep UI clean instead of silently failing
            if (!idA || !idB) {
                if (boxA) boxA.innerHTML = "";
                if (boxB) boxB.innerHTML = "";
                if (boxO) boxO.innerHTML = "";
                if (insight) insight.textContent = "Select Card A and Card B to render the pentagon comparison.";
                return;
            }

            const cardA = (state.cards || []).find(c => c.id === idA);
            const cardB = (state.cards || []).find(c => c.id === idB);

            if (!cardA || !cardB) {
                if (boxA) boxA.innerHTML = "";
                if (boxB) boxB.innerHTML = "";
                if (boxO) boxO.innerHTML = "";
                if (insight) insight.textContent = "Selected cards were not found. Try re-selecting them.";
                return;
            }

            if (insight) insight.textContent = "";
            buildCompareRadar(cardA, cardB);
        }


        document.querySelector("#cmpA")
            .addEventListener("change", updateCompareRadar);

        document.querySelector("#cmpB")
            .addEventListener("change", updateCompareRadar);




        loadBiomes();

        /* ==============================
           CROSSWAVEOMEGA BIOME MAP (v12)
        ================================ */
        let PLANET_BIOME_MAP = {};

        async function loadCrosswaveBiomeMap() {
            try {
                const res = await fetch("https://crosswaveomega.github.io/helldiversplanettable/planet_table");
                const htmlText = await res.text();
                const doc = new DOMParser().parseFromString(htmlText, "text/html");

                doc.querySelectorAll("table tr").forEach(row => {
                    const cols = row.querySelectorAll("td");
                    if (cols.length < 3) return;
                    const planet = cols[0].textContent.trim().toLowerCase();
                    const biome = cols[2].textContent.trim();
                    if (planet && biome) {
                        PLANET_BIOME_MAP[planet] = biome;
                    }
                });

                console.log("[BiomeMap] Crosswave loaded:", Object.keys(PLANET_BIOME_MAP).length);
            } catch (e) {
                console.warn("[BiomeMap] Crosswave load failed", e);
            }
        }

        const __oldGetPlanetBiome = window.getPlanetBiome;
        window.getPlanetBiome = function (p) {
            if (!p) return "Unknown";
            const key = (p.name || "").toLowerCase();
            if (PLANET_BIOME_MAP[key]) return PLANET_BIOME_MAP[key];
            if (__oldGetPlanetBiome) return __oldGetPlanetBiome(p);
            return "Unknown";
        };

        document.addEventListener("DOMContentLoaded", () => {
            loadCrosswaveBiomeMap();
        });


        /* ==============================
           LOCAL BIOME TABLE (v14)
           Reads: "Planet, sector, Biome, Hazards.txt" in same folder

           IMPORTANT:
           - Auto-load via fetch() works only when the HTML is served over http/https (localhost or GitHub Pages).
           - When opened by double-click (file://), browsers block fetch() to sibling files.
             So we provide a manual loader using <input type="file"> (works on file://).
        ================================ */

        let LOCAL_PLANET_BIOME_MAP = Object.create(null);
        // refresh currently rolled planet
        if (state?.spin?.planet) { renderSpin(state.spin); }

        function parseLocalPlanetBiomeTxt(text) {
            const map = Object.create(null);
            const lines = String(text || "").split(/\r?\n/);
            for (const raw of lines) {
                const line = raw.trim();
                if (!line) continue;
                if (/planet\s+name/i.test(line) && /biome/i.test(line)) continue;

                // Expected TAB format:
                // Index \t Planet Name \t Sector \t Biome \t Hazards
                const cols = line.split(/\t+/).map(s => s.trim());
                if (cols.length >= 4) {
                    const planet = (cols[1] || "").trim();
                    const biome = (cols[3] || "").trim();
                    if (planet && biome) map[normalizePlanetKey(planet)] = biome;
                    continue;
                }

                // Backup: CSV-ish
                const cols2 = line.split(",").map(s => s.trim());
                if (cols2.length >= 3) {
                    const planet = (cols2[0] || "").trim();
                    const biome = (cols2[2] || "").trim();
                    if (planet && biome) map[normalizePlanetKey(planet)] = biome;
                }
            }
            return map;
        }

        async function tryAutoLoadLocalBiomeTxt() {
            try {
                const res = await fetch("./HD2 Roulette files/Planet, sector, Biome, Hazards.txt", { cache: "no-store" });
                if (!res.ok) throw new Error("HTTP " + res.status);
                const text = await res.text();
                LOCAL_PLANET_BIOME_MAP = parseLocalPlanetBiomeTxt(text);

                const help = document.querySelector("#biomeHelpRow");
                if (help) help.style.display = "none";
                if (state?.spin?.planet) { renderSpin(state.spin); }
                // refresh currently rolled planet
                if (state?.spin?.planet) { renderSpin(state.spin); }
                console.log("[BiomeMap] Local TXT auto-loaded:", Object.keys(LOCAL_PLANET_BIOME_MAP).length);
                const helpRow = document.getElementById("biomeHelpRow");
                if (helpRow) helpRow.style.display = "none";
                // refresh spin UI if planet already rolled
                try { renderSpin && renderSpin(); } catch (e) { }
                return true;
            } catch (e) {
                console.warn("[BiomeMap] Local TXT auto-load blocked/failed:", e);
                const helpRow = document.getElementById("biomeHelpRow");
                if (helpRow) helpRow.style.display = "block";
                return false;
            }
            finally {
                const help = document.querySelector("#biomeHelpRow");
                const has = LOCAL_PLANET_BIOME_MAP && Object.keys(LOCAL_PLANET_BIOME_MAP).length > 0;
                if (help) help.style.display = has ? "none" : "block";
            }
        }
        // show help row toggle end

        function manualLoadLocalBiomeTxtFromInput(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    LOCAL_PLANET_BIOME_MAP = parseLocalPlanetBiomeTxt(String(reader.result || ""));
                    // refresh currently rolled planet
                    if (state?.spin?.planet) { renderSpin(state.spin); }
                    console.log("[BiomeMap] Local TXT loaded (manual):", Object.keys(LOCAL_PLANET_BIOME_MAP).length);
                    const helpRow = document.getElementById("biomeHelpRow");
                    if (helpRow) helpRow.style.display = "none";
                    try { renderSpin && renderSpin(); } catch (e) { }
                } catch (err) {
                    console.warn("[BiomeMap] Manual parse failed:", err);
                }
            };
            reader.readAsText(file);
        }

        document.addEventListener("DOMContentLoaded", () => {
            // Create hidden file input once
            let input = document.getElementById("biomeTxtFile");
            if (!input) {
                input = document.createElement("input");
                input.type = "file";
                input.accept = ".txt,text/plain";
                input.id = "biomeTxtFile";
                input.style.display = "none";
                document.body.appendChild(input);
                input.addEventListener("change", () => {
                    manualLoadLocalBiomeTxtFromInput(input.files && input.files[0]);
                    input.value = ""; // allow re-pick same file
                });
            }

            const btn = document.getElementById("btnLoadBiomeTxt");
            if (btn) {
                btn.addEventListener("click", (ev) => {
                    ev.preventDefault();
                    input.click();
                });
            }

            // Attempt auto-load first (works on localhost/GitHub)
            tryAutoLoadLocalBiomeTxt();
        });
    </script>


</body>
</html>
